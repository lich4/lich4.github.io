<!DOCTYPE html>
<html lang="zh-CN"
  dir="ltr">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width">



<link rel="icon" type="image/ico" href="https://lich4.github.io//favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lich4.github.io//favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lich4.github.io//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://lich4.github.io//android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://lich4.github.io//apple-touch-icon.png">

<meta name="description" content=""/>

<title>
    
    OLLVM学习 | 超哥的博客
    
</title>

<link rel="canonical" href="https://lich4.github.io/cpp_posts/20240826_ollvm/"/>












<link rel="stylesheet" href="/assets/combined.min.cbcb816aefdb3b7380c5921cbb3b89d12f07742cb3f869754adb56da84f0d729.css" media="all">









  </head>

  

  
  
  

  <body class="light">

    <div class="content">
      <header>
        

<div class="header">

    

</div>

      </header>

      <main class="main">
        





<div class="breadcrumbs">
    
    <a href="/">Home</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a href="/cpp_posts/">Cpp_posts</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a class="breadcrumbs-current" href="/cpp_posts/20240826_ollvm/">OLLVM学习</a>
</div>



<div >

  <div class="single-intro-container">

    

    <h1 class="single-title">OLLVM学习</h1>
    
    <p class="single-summary">OLLVM学习</p>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2024-08-26T00:00:00&#43;00:00">August 26, 2024</time>
      

      
    </p>

  </div>

  

  
  
  

  

  
  <aside class="toc">
    <p><strong>Table of contents</strong></p>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#llvm">LLVM</a>
      <ul>
        <li><a href="#llvm简介">LLVM简介</a></li>
      </ul>
    </li>
    <li><a href="#llvm-ir">LLVM IR</a>
      <ul>
        <li><a href="#ir简介">IR简介</a></li>
        <li><a href="#ir指令">IR指令</a></li>
      </ul>
    </li>
    <li><a href="#llvm-pass">LLVM Pass</a>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#编码">编码</a></li>
        <li><a href="#测试">测试</a></li>
        <li><a href="#pass加载时机">Pass加载时机</a></li>
      </ul>
    </li>
    <li><a href="#ollvm">OLLVM</a>
      <ul>
        <li><a href="#现存ollvm项目汇总">现存OLLVM项目汇总</a></li>
        <li><a href="#混淆控制方式">混淆控制方式</a></li>
      </ul>
    </li>
    <li><a href="#常量加密">常量加密</a>
      <ul>
        <li><a href="#hikari-stringencryption模块分析">Hikari StringEncryption模块分析</a></li>
        <li><a href="#goron-indirectglobalvariable模块分析">goron IndirectGlobalVariable模块分析</a></li>
        <li><a href="#实验将静态字符串转换为栈字符串">实验:将静态字符串转换为栈字符串</a></li>
      </ul>
    </li>
    <li><a href="#控制流级别的混淆">控制流级别的混淆</a>
      <ul>
        <li><a href="#hikari-splitbasicblock模块分析">Hikari SplitBasicBlock模块分析</a></li>
        <li><a href="#hikari-flattening模块分析">Hikari Flattening模块分析</a></li>
        <li><a href="#pluto-flattening模块分析">Pluto Flattening模块分析</a></li>
        <li><a href="#hikari-boguscontrolflow模块分析">Hikari BogusControlFlow模块分析</a></li>
        <li><a href="#pluto-mbaobfuscation模块分析">Pluto MbaObfuscation模块分析</a></li>
      </ul>
    </li>
    <li><a href="#函数级别的混淆">函数级别的混淆</a>
      <ul>
        <li><a href="#hikari-functioncallobfuscate模块分析">Hikari FunctionCallObfuscate模块分析</a></li>
        <li><a href="#hikari-functionwrapper模块分析">Hikari FunctionWrapper模块分析</a></li>
      </ul>
    </li>
    <li><a href="#指令级别的混淆">指令级别的混淆</a>
      <ul>
        <li><a href="#hikari-indirectbranch模块分析">Hikari IndirectBranch模块分析</a></li>
        <li><a href="#hikari-substitution模块分析">Hikari Substitution模块分析</a></li>
        <li><a href="#goron-indirectcall模块分析">goron IndirectCall模块分析</a></li>
      </ul>
    </li>
    <li><a href="#ollvm对抗">OLLVM对抗</a>
      <ul>
        <li><a href="#d810">D810</a></li>
        <li><a href="#angr">angr</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>
  

  

  <div class="single-content">
    <h2 id="llvm">LLVM</h2>
<h3 id="llvm简介">LLVM简介</h3>
<p>  LLVM(Low Level Virtual Machine)是苹果公司的开源编译器框架, 包含包括Clang在内的一系列编译相关工具, 于2000年左右开发, LLVM/Clang从XCode8起作为XCode默认编译器, LLVM作为以下语言的开发工具链: C, C++, Objective-C, Swift, Ruby, Python, Haskell, Rust, D, PHP, Pure, Lua, Julia. 相比同样庞大但臃肿的GCC, LLVM的模块化设计更利于扩展和维护, 因此LLVM取代GCC是必然趋势. LLVM包含如下组件:</p>
<ul>
<li>Clang, 用于做C/C++/Objective-C的编译前端</li>
<li>LLDB, 调试器</li>
<li>libc++, 提供c++基础库</li>
<li>compiler-rt</li>
<li>MLIR</li>
<li>OpenMP</li>
<li>libclc</li>
<li>klee</li>
<li>LLD 链接器</li>
<li>BOLT</li>
</ul>
<p>第三方:</p>
<ul>
<li>rustc, 用于rust的编译前端</li>
<li>swiftc, 用于swift的编译前端</li>
<li>codon, 用于python的编译前端</li>
</ul>
<p>历史更新功能点:</p>
<ul>
<li>由Chris Lattner于2000创建</li>
<li>LLVM1.0(2003), 首次公开发布</li>
<li>LLVM3.0(2012), 引入了新的JIT编译器, 支持C++11, 基于SSA的内存安全转换, 全局ISel重构</li>
<li>LLVM3.7(2015), 支持OpenMP3.1, Clang Static Analyzer增强,AArch64支持</li>
<li>LLVM5.0(2016), 支持C++14, 引入了新的代码分析和优化技术</li>
<li>LLVM9.0(2019), 支持C++17, JIT支持WebAssembly, 优化RISC-V, 优化IR</li>
<li>LLVM12.0(2021), 支持C++20, 引入LTO优化, 支持arm64e</li>
</ul>
<p>XCode与LLVM版本对应:</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">XCode</th>
          <th style="text-align: left">LLVM</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">11.x</td>
          <td style="text-align: left">11</td>
      </tr>
      <tr>
          <td style="text-align: left">12.x</td>
          <td style="text-align: left">12</td>
      </tr>
      <tr>
          <td style="text-align: left">13.x</td>
          <td style="text-align: left">13</td>
      </tr>
      <tr>
          <td style="text-align: left">14.x</td>
          <td style="text-align: left">14</td>
      </tr>
      <tr>
          <td style="text-align: left">15.x</td>
          <td style="text-align: left">15</td>
      </tr>
  </tbody>
</table>
<h2 id="llvm-ir">LLVM IR</h2>
<h3 id="ir简介">IR简介</h3>
<p>  IR(Intermediate Representation), 是一种LLVM定义的介于源码和汇编的中间语言, 语法类似于汇编. IR主要用于解决跨平台编译的问题, 同时也能解决优化/混淆/扩展问题. IR手册 <a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a>, 以下是IR相关的命令:</p>
<ul>
<li>llc 将bitcode转换为asm/obj</li>
<li>lld 将多个bitcode/obj编译为二进制</li>
<li>lli bitcode解释器</li>
<li>opt 优化bitcode</li>
<li>llvm-ar 操作archive</li>
<li>llvm-as 将ll转换为bitcode, ll为人类可读字节码格式</li>
<li>llvm-cxxfilt c++修饰名转普通</li>
<li>llvm-dis bitcode转ll</li>
<li>llvm-extract 从bitcode提取函数</li>
<li>llvm-link 将多个bitcode合并为一个bitcode</li>
<li>clang -emit-llvm -c 源码编译为bitcode</li>
<li>clang -emit-llvm -S 源码编译为ll</li>
</ul>
<p>第三方:</p>
<ul>
<li><code>swiftc -emit-assembly /tmp/1.swift -o /tmp/1.bc</code> Swift源码编译为汇编</li>
<li><code>swiftc -emit-bc /tmp/1.swift -o /tmp/1.bc</code> Swift源码编译为bitcode</li>
<li><code>swiftc -emit-ir /tmp/1.swift -o /tmp/1.ll</code> Swift源码编译为ll</li>
<li><code>cargo rustc -- --emit=asm</code>或<code>rustc --emit=asm 1.rs</code> Rust源码编译为汇编</li>
<li><code>cargo rustc -- --emit=llvm-bc</code>或<code>rustc --emit=llvm-bc 1.rs</code> Rust源码编译为bitcode</li>
<li><code>cargo rustc -- --emit=llvm-ir</code>或<code>rustc --emit=llvm-ir 1.rs</code> Rust源码编译为ll</li>
<li><code>codon build -llvm 1.py</code> Python源码编译为ll</li>
</ul>
<p>测试用例:</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// 1.cpp
</span></span><span style="display:flex;"><span>#include &lt;stdio.h&gt;
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#5f5fff">char</span><span style="color:#ec0000">**</span> argv) {
</span></span><span style="display:flex;"><span>  printf(<span style="color:#008900">&#34;Hello World!</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>源码交叉编译为bitcode/ll</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span># for MacOS x86_64
</span></span><span style="display:flex;"><span>./clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -arch x86_64 -emit-llvm -c /tmp/1.cpp --output<span style="color:#ec0000">=</span>/tmp/1.bc
</span></span><span style="display:flex;"><span>./clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -arch x86_64 -emit-llvm -S /tmp/1.cpp --output<span style="color:#ec0000">=</span>/tmp/1.ll
</span></span><span style="display:flex;"><span># 如果要用XCode自带clang需使用xcrun, 以下同, 不建议用XCode clang, 因为不同版本Clang/llc/lld/lli互相不兼容, 且XCode不提供llc/lld/lli
</span></span><span style="display:flex;"><span>xcrun --sdk macosx clang -arch x86_64 -emit-llvm -c /tmp/1.cpp --output<span style="color:#ec0000">=</span>/tmp/1.bc
</span></span></code></pre></div><pre tabindex="0"><code class="language-IR" data-lang="IR">; ModuleID = &#39;/tmp/1.cpp&#39;
source_filename = &#34;/tmp/1.cpp&#34;
target datalayout = &#34;e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128&#34;
target triple = &#34;x86_64-apple-macosx11.3.0&#34;

@.str = private unnamed_addr constant [14 x i8] c&#34;Hello World!\0A\00&#34;, align 1

; Function Attrs: mustprogress noinline norecurse optnone ssp uwtable
define noundef i32 @main(i32 noundef %0, ptr noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca ptr, align 8
  store i32 0, ptr %3, align 4
  store i32 %0, ptr %4, align 4
  store ptr %1, ptr %5, align 8
  %6 = call i32 (ptr, ...) @printf(ptr noundef @.str)
  ret i32 0
}

declare i32 @printf(ptr noundef, ...) #1

attributes #0 = { mustprogress noinline norecurse optnone ssp uwtable &#34;frame-pointer&#34;=&#34;all&#34; &#34;min-legal-vector-width&#34;=&#34;0&#34; &#34;no-trapping-math&#34;=&#34;true&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;penryn&#34; &#34;target-features&#34;=&#34;+cmov,+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&#34; &#34;tune-cpu&#34;=&#34;generic&#34; }
attributes #1 = { &#34;frame-pointer&#34;=&#34;all&#34; &#34;no-trapping-math&#34;=&#34;true&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;penryn&#34; &#34;target-features&#34;=&#34;+cmov,+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&#34; &#34;tune-cpu&#34;=&#34;generic&#34; }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 2, !&#34;SDK Version&#34;, [2 x i32] [i32 11, i32 3]}
!1 = !{i32 1, !&#34;wchar_size&#34;, i32 4}
!2 = !{i32 8, !&#34;PIC Level&#34;, i32 2}
!3 = !{i32 7, !&#34;uwtable&#34;, i32 2}
!4 = !{i32 7, !&#34;frame-pointer&#34;, i32 2}
!5 = !{!&#34;clang version 19.0.0git&#34;}
</code></pre><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span># for iOS arm64
</span></span><span style="display:flex;"><span>./clang -isysroot <span style="color:#008900">`</span>xcrun --sdk iphoneos --show-sdk-path<span style="color:#008900">`</span> -arch arm64 -emit-llvm -c /tmp/1.cpp --output<span style="color:#ec0000">=</span>/tmp/1.bc
</span></span><span style="display:flex;"><span>./clang -isysroot <span style="color:#008900">`</span>xcrun --sdk iphoneos --show-sdk-path<span style="color:#008900">`</span> -arch arm64 -emit-llvm -S /tmp/1.cpp --output<span style="color:#ec0000">=</span>/tmp/1.ll
</span></span></code></pre></div><pre tabindex="0"><code class="language-IR" data-lang="IR">; ModuleID = &#39;/tmp/1.cpp&#39;
source_filename = &#34;/tmp/1.cpp&#34;
target datalayout = &#34;e-m:o-i64:64-i128:128-n32:64-S128-Fn32&#34;
target triple = &#34;arm64-apple-ios14.5.0&#34;

@.str = private unnamed_addr constant [14 x i8] c&#34;Hello World!\0A\00&#34;, align 1

; Function Attrs: mustprogress noinline norecurse optnone ssp uwtable(sync)
define noundef i32 @main(i32 noundef %0, ptr noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca ptr, align 8
  store i32 0, ptr %3, align 4
  store i32 %0, ptr %4, align 4
  store ptr %1, ptr %5, align 8
  %6 = call i32 (ptr, ...) @printf(ptr noundef @.str)
  ret i32 0
}

declare i32 @printf(ptr noundef, ...) #1

attributes #0 = { mustprogress noinline norecurse optnone ssp uwtable(sync) &#34;frame-pointer&#34;=&#34;non-leaf&#34; &#34;no-trapping-math&#34;=&#34;true&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;apple-a7&#34; &#34;target-features&#34;=&#34;+aes,+fp-armv8,+neon,+perfmon,+sha2,+v8a,+zcm,+zcz&#34; }
attributes #1 = { &#34;frame-pointer&#34;=&#34;non-leaf&#34; &#34;no-trapping-math&#34;=&#34;true&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;apple-a7&#34; &#34;target-features&#34;=&#34;+aes,+fp-armv8,+neon,+perfmon,+sha2,+v8a,+zcm,+zcz&#34; }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 2, !&#34;SDK Version&#34;, [2 x i32] [i32 14, i32 5]}
!1 = !{i32 1, !&#34;wchar_size&#34;, i32 4}
!2 = !{i32 8, !&#34;PIC Level&#34;, i32 2}
!3 = !{i32 7, !&#34;uwtable&#34;, i32 1}
!4 = !{i32 7, !&#34;frame-pointer&#34;, i32 1}
!5 = !{!&#34;clang version 19.0.0git&#34;}; ModuleID = &#39;/tmp/1.cpp&#39;
source_filename = &#34;/tmp/1.cpp&#34;
target datalayout = &#34;e-m:o-i64:64-i128:128-n32:64-S128-Fn32&#34;
target triple = &#34;arm64-apple-ios14.5.0&#34;

@.str = private unnamed_addr constant [14 x i8] c&#34;Hello World!\0A\00&#34;, align 1

; Function Attrs: mustprogress noinline norecurse optnone ssp uwtable(sync)
define noundef i32 @main(i32 noundef %0, ptr noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca ptr, align 8
  store i32 0, ptr %3, align 4
  store i32 %0, ptr %4, align 4
  store ptr %1, ptr %5, align 8
  %6 = call i32 (ptr, ...) @printf(ptr noundef @.str)
  ret i32 0
}

declare i32 @printf(ptr noundef, ...) #1

attributes #0 = { mustprogress noinline norecurse optnone ssp uwtable(sync) &#34;frame-pointer&#34;=&#34;non-leaf&#34; &#34;no-trapping-math&#34;=&#34;true&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;apple-a7&#34; &#34;target-features&#34;=&#34;+aes,+fp-armv8,+neon,+perfmon,+sha2,+v8a,+zcm,+zcz&#34; }
attributes #1 = { &#34;frame-pointer&#34;=&#34;non-leaf&#34; &#34;no-trapping-math&#34;=&#34;true&#34; &#34;stack-protector-buffer-size&#34;=&#34;8&#34; &#34;target-cpu&#34;=&#34;apple-a7&#34; &#34;target-features&#34;=&#34;+aes,+fp-armv8,+neon,+perfmon,+sha2,+v8a,+zcm,+zcz&#34; }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 2, !&#34;SDK Version&#34;, [2 x i32] [i32 14, i32 5]}
!1 = !{i32 1, !&#34;wchar_size&#34;, i32 4}
!2 = !{i32 8, !&#34;PIC Level&#34;, i32 2}
!3 = !{i32 7, !&#34;uwtable&#34;, i32 1}
!4 = !{i32 7, !&#34;frame-pointer&#34;, i32 1}
!5 = !{!&#34;clang version 19.0.0git&#34;}
</code></pre><p>bitcode/ll编译为asm/obj</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./llc --filetype<span style="color:#ec0000">=</span>asm /tmp/1.ll -o /tmp/1.asm
</span></span><span style="display:flex;"><span>./llc --filetype<span style="color:#ec0000">=</span>obj /tmp/1.ll -o /tmp/1.obj
</span></span><span style="display:flex;"><span>./llc --filetype<span style="color:#ec0000">=</span>asm /tmp/1.bc -o /tmp/1.asm
</span></span><span style="display:flex;"><span>./llc --filetype<span style="color:#ec0000">=</span>obj /tmp/1.bc -o /tmp/1.obj
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>	<span style="color:#5f5fff">.section</span>	<span style="color:#008900">__TEXT</span>,<span style="color:#008900">__text</span>,<span style="color:#008900">regular</span>,<span style="color:#008900">pure_instructions</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.build_version</span> <span style="color:#008900">ios</span>, <span style="color:#008900">14</span>, <span style="color:#008900">5</span>	<span style="color:#008900">sdk_version</span> <span style="color:#008900">14</span>, <span style="color:#008900">5</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.globl</span>	<span style="color:#008900">_main</span>                           ; -- Begin function main
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.p2align</span>	<span style="color:#008900">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">_main:</span>                                  ; @main
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.cfi_startproc</span>
</span></span><span style="display:flex;"><span>; %bb.0:
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">sub</span>	<span style="color:#008900">sp</span>, <span style="color:#008900">sp</span>, #32
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">stp</span>	<span style="color:#008900">x29</span>, <span style="color:#008900">x30</span>, [<span style="color:#008900">sp</span>, #16]             ; 16-byte Folded Spill
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">add</span>	<span style="color:#008900">x29</span>, <span style="color:#008900">sp</span>, #16
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.cfi_def_cfa</span> <span style="color:#008900">w29</span>, <span style="color:#008900">16</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.cfi_offset</span> <span style="color:#008900">w30</span>, -<span style="color:#008900">8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.cfi_offset</span> <span style="color:#008900">w29</span>, -<span style="color:#008900">16</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">stur</span>	<span style="color:#008900">wzr</span>, [<span style="color:#008900">x29</span>, #-4]
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">str</span>	<span style="color:#008900">w0</span>, [<span style="color:#008900">sp</span>, #8]
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">str</span>	<span style="color:#008900">x1</span>, [<span style="color:#008900">sp</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">adrp</span>	<span style="color:#008900">x0</span>, <span style="color:#008900">l_.str@PAGE</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">add</span>	<span style="color:#008900">x0</span>, <span style="color:#008900">x0</span>, <span style="color:#008900">l_.str@PAGEOFF</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">bl</span>	<span style="color:#008900">_printf</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">mov</span>	<span style="color:#008900">w0</span>, #0                          ; =0x0
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">ldp</span>	<span style="color:#008900">x29</span>, <span style="color:#008900">x30</span>, [<span style="color:#008900">sp</span>, #16]             ; 16-byte Folded Reload
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">add</span>	<span style="color:#008900">sp</span>, <span style="color:#008900">sp</span>, #32
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">ret</span>
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.cfi_endproc</span>
</span></span><span style="display:flex;"><span>                                        ; -- End function
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.section</span>	<span style="color:#008900">__TEXT</span>,<span style="color:#008900">__cstring</span>,<span style="color:#008900">cstring_literals</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">l_.str:</span>                                 ; @.str
</span></span><span style="display:flex;"><span>	<span style="color:#5f5fff">.asciz</span>	<span style="color:#008900">&#34;Hello World!\n&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">.subsections_via_symbols</span>
</span></span></code></pre></div><p>bitcode编译为可执行程序:</p>
<blockquote>
<p>lld是通用程序, 不同平台需要调用不同二进制</p>
</blockquote>
<ul>
<li>Unix: ld.lld</li>
<li>macOS: ld64.lld</li>
<li>Windows: lld-link</li>
<li>WebAssembly: wasm-ld</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./ld64.lld -arch arm64 -platform_version ios 12.0 14.5 -dylib /tmp/1.bc -o /tmp/1.exe
</span></span></code></pre></div><p>运行bitcode</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./lli /tmp/1.ll
</span></span><span style="display:flex;"><span>./lli /tmp/1.bc
</span></span><span style="display:flex;"><span># 均输出&#34;Hello World!&#34;
</span></span></code></pre></div><h3 id="ir指令">IR指令</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Instruction
</span></span><span style="display:flex;"><span>UnaryInstruction        一元指令
</span></span><span style="display:flex;"><span>  UnaryOperator         一元操作
</span></span><span style="display:flex;"><span>  CastInst              强制转换
</span></span><span style="display:flex;"><span>    PossiblyNonNegInst  非负指令
</span></span><span style="display:flex;"><span>BinaryOperator          二进制操作
</span></span><span style="display:flex;"><span>  PossiblyDisjointInst
</span></span><span style="display:flex;"><span>CmpInst                 比较操作
</span></span><span style="display:flex;"><span>CallBase                调用操作
</span></span><span style="display:flex;"><span>FuncletPadInst    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    Super
</span></span><span style="display:flex;"><span>AllocaInst          UnaryInstruction    An instruction to allocate memory on the stack.
</span></span><span style="display:flex;"><span>LoadInst            UnaryInstruction    An instruction for reading from memory. This uses the SubclassData
</span></span><span style="display:flex;"><span>                                        field in Value to store whether or not the load is volatile.
</span></span><span style="display:flex;"><span>StoreInst           Instruction         An instruction for storing to memory.
</span></span><span style="display:flex;"><span>FenceInst           Instruction         An instruction for ordering other memory operations.
</span></span><span style="display:flex;"><span>AtomicCmpXchgInst   Instruction         An instruction that atomically checks whether a specified value 
</span></span><span style="display:flex;"><span>                                        is in a memory location, and, if it is, stores a new value there. 
</span></span><span style="display:flex;"><span>                                        The value returned by this instruction is a pair containing the 
</span></span><span style="display:flex;"><span>                                        original value as first element, and an i1 indicating success 
</span></span><span style="display:flex;"><span>                                        (true) or failure (false) as second element.
</span></span><span style="display:flex;"><span>AtomicRMWInst       Instruction         An instruction that atomically reads a memory location, combines 
</span></span><span style="display:flex;"><span>                                        it with another value, and then stores the result back.  Returns 
</span></span><span style="display:flex;"><span>                                        the old value.
</span></span><span style="display:flex;"><span>GetElementPtrInst   Instruction         An instruction for type-safe pointer arithmetic to access elements 
</span></span><span style="display:flex;"><span>                                        of arrays and structs
</span></span><span style="display:flex;"><span>ICmpInst            CmpInst             This instruction compares its operands according to the predicate 
</span></span><span style="display:flex;"><span>                                        given to the constructor. It only operates on integers or pointers. 
</span></span><span style="display:flex;"><span>                                        The operands must be identical types. Represent an integer comparison 
</span></span><span style="display:flex;"><span>                                        operator.
</span></span><span style="display:flex;"><span>FCmpInst            CmpInst             This instruction compares its operands according to the predicate 
</span></span><span style="display:flex;"><span>                                        given to the constructor. It only operates on floating point values 
</span></span><span style="display:flex;"><span>                                        or packed vectors of floating point values. The operands must be 
</span></span><span style="display:flex;"><span>                                        identical types. Represents a floating point comparison operator.
</span></span><span style="display:flex;"><span>CallInst            CallBase            This class represents a function call, abstracting a target machine&#39;s 
</span></span><span style="display:flex;"><span>                                        calling convention. This class uses low bit of the SubClassData
</span></span><span style="display:flex;"><span>                                        field to indicate whether or not this is a tail call. The rest 
</span></span><span style="display:flex;"><span>                                        of the bits hold the calling convention of the call.
</span></span><span style="display:flex;"><span>SelectInst          Instruction         This class represents the LLVM &#39;select&#39; instruction.
</span></span><span style="display:flex;"><span>VAArgInst           UnaryInstruction    This class represents the va_arg llvm instruction, which returns 
</span></span><span style="display:flex;"><span>                                        an argument of the specified type given a va_list and increments 
</span></span><span style="display:flex;"><span>                                        that list
</span></span><span style="display:flex;"><span>ExtractElementInst  Instruction         This instruction extracts a single (scalar) element from a VectorType value
</span></span><span style="display:flex;"><span>InsertElementInst   Instruction         This instruction inserts a single (scalar) element into a VectorType value
</span></span><span style="display:flex;"><span>ShuffleVectorInst   Instruction         This instruction constructs a fixed permutation of two input vectors. 
</span></span><span style="display:flex;"><span>                                        For each element of the result vector, the shuffle mask selects an 
</span></span><span style="display:flex;"><span>                                        element from one of the input vectors to copy to the result. 
</span></span><span style="display:flex;"><span>                                        Non-negative elements in the mask represent an index into the 
</span></span><span style="display:flex;"><span>                                        concatenated pair of input vectors. PoisonMaskElem (-1) specifies 
</span></span><span style="display:flex;"><span>                                        that the result element is poison. For scalable vectors, all the 
</span></span><span style="display:flex;"><span>                                        elements of the mask must be 0 or -1. This requirement may be 
</span></span><span style="display:flex;"><span>                                        relaxed in the future.
</span></span><span style="display:flex;"><span>ExtractValueInst    UnaryInstruction    This instruction extracts a struct member or array element value 
</span></span><span style="display:flex;"><span>                                        from an aggregate value.
</span></span><span style="display:flex;"><span>InsertValueInst     Instruction         This instruction inserts a struct field of array element value 
</span></span><span style="display:flex;"><span>                                        into an aggregate value.
</span></span><span style="display:flex;"><span>PHINode             Instruction         PHINode - The PHINode class is used to represent the magical mystical 
</span></span><span style="display:flex;"><span>                                        PHI node, that can not exist in nature, but can be synthesized in a 
</span></span><span style="display:flex;"><span>                                        computer scientist&#39;s overactive imagination.
</span></span><span style="display:flex;"><span>LandingPadInst      Instruction         The landingpad instruction holds all of the information necessary 
</span></span><span style="display:flex;"><span>                                        to generate correct exception handling. The landingpad instruction 
</span></span><span style="display:flex;"><span>                                        cannot be moved from the top of a landing pad block, which itself 
</span></span><span style="display:flex;"><span>                                        is accessible only from the &#39;unwind&#39; edge of an invoke. This uses 
</span></span><span style="display:flex;"><span>                                        the SubclassData field in Value to store whether or not the landingpad 
</span></span><span style="display:flex;"><span>                                        is a cleanup.
</span></span><span style="display:flex;"><span>ReturnInst          Instruction         Return a value (possibly void), from a function. Execution does 
</span></span><span style="display:flex;"><span>                                        not continue in this function any longer.
</span></span><span style="display:flex;"><span>BranchInst          Instruction         Conditional or Unconditional Branch instruction.
</span></span><span style="display:flex;"><span>SwitchInst          Instruction         Multiway switch.
</span></span><span style="display:flex;"><span>IndirectBrInst      Instruction         Indirect Branch Instruction.
</span></span><span style="display:flex;"><span>InvokeInst          CallBase            Invoke instruction. The SubclassData field is used to hold the 
</span></span><span style="display:flex;"><span>                                        calling convention of the call.
</span></span><span style="display:flex;"><span>CallBrInst          CallBase            CallBr instruction, tracking function calls that may not return 
</span></span><span style="display:flex;"><span>                                        control but instead transfer it to a third location. The SubclassData 
</span></span><span style="display:flex;"><span>                                        field is used to hold the calling convention of the call.
</span></span><span style="display:flex;"><span>ResumeInst          Instruction         Resume the propagation of an exception.
</span></span><span style="display:flex;"><span>CatchSwitchInst     Instruction
</span></span><span style="display:flex;"><span>CleanupPadInst      FuncletPadInst
</span></span><span style="display:flex;"><span>CatchPadInst        FuncletPadInst
</span></span><span style="display:flex;"><span>CatchReturnInst     Instruction
</span></span><span style="display:flex;"><span>CleanupReturnInst   Instruction
</span></span><span style="display:flex;"><span>UnreachableInst     Instruction         This function has undefined behavior. In particular, the presence 
</span></span><span style="display:flex;"><span>                                        of this instruction indicates some higher level knowledge that 
</span></span><span style="display:flex;"><span>                                        the end of the block cannot be reached.
</span></span><span style="display:flex;"><span>TruncInst           CastInst            This class represents a truncation of integer types.
</span></span><span style="display:flex;"><span>ZExtInst            CastInst            This class represents zero extension of integer types.
</span></span><span style="display:flex;"><span>SExtInst            CastInst            This class represents a sign extension of integer types.
</span></span><span style="display:flex;"><span>FPTruncInst         CastInst            This class represents a truncation of floating point types.
</span></span><span style="display:flex;"><span>FPExtInst           CastInst            This class represents an extension of floating point types.
</span></span><span style="display:flex;"><span>UIToFPInst          CastInst            This class represents a cast unsigned integer to floating point.
</span></span><span style="display:flex;"><span>SIToFPInst          CastInst            This class represents a cast from signed integer to floating point.
</span></span><span style="display:flex;"><span>FPToUIInst          CastInst            This class represents a cast from floating point to unsigned integer.
</span></span><span style="display:flex;"><span>FPToSIInst          CastInst            This class represents a cast from floating point to signed integer.
</span></span><span style="display:flex;"><span>IntToPtrInst        CastInst            This class represents a cast from an integer to a pointer.
</span></span><span style="display:flex;"><span>PtrToIntInst        CastInst            This class represents a cast from a pointer to an integer.
</span></span><span style="display:flex;"><span>BitCastInst         CastInst            This class represents a no-op cast from one type to another.
</span></span><span style="display:flex;"><span>AddrSpaceCastInst   CastInst            This class represents a conversion between pointers from one address
</span></span><span style="display:flex;"><span>                                        space to another.
</span></span><span style="display:flex;"><span>FreezeInst          UnaryInstruction    This class represents a freeze function that returns random concrete 
</span></span><span style="display:flex;"><span>                                        value if an operand is either a poison value or an undef value
</span></span></code></pre></div><h2 id="llvm-pass">LLVM Pass</h2>
<h3 id="简介">简介</h3>
<p>  LLVM Pass是LLVM提供的用于优化/分析/处理IR的组件, 第三方可以自由开发Pass从而干涉编译过程, 实现代码优化/静态分析/代码混淆. 上一节学习了CMake的基本用法, 现在来用CMake实现最简单的LLVM Pass. 笔者的环境仍是MacOS. 需要注意的是LLVM Pass从LLVM版本支持可分为Legacy Pass和New Pass, 前者是历史遗留, 具体兼容性如下表.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">LLVM</th>
          <th style="text-align: left">默认</th>
          <th style="text-align: left">可选</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">5-12</td>
          <td style="text-align: left">LegacyPassManager</td>
          <td style="text-align: left">-fexperimental-new-pass-manager 启用New, 该功能有限</td>
      </tr>
      <tr>
          <td style="text-align: left">13-14</td>
          <td style="text-align: left">NewPassManager</td>
          <td style="text-align: left">-flegacy-pass-manager 启用 Legacy</td>
      </tr>
      <tr>
          <td style="text-align: left">15-?</td>
          <td style="text-align: left">NewPassManager</td>
          <td style="text-align: left"></td>
      </tr>
  </tbody>
</table>
<p>   Pass从类型可分为FunctionPass, ModulePass, LoopPass, RegionPass, MachineFunctionPass, AnalysePass, CallGraphSCCPass等, FunctionPass用于做函数层面的操作, ModulePass用于做模块层面的操作(模块包括函数, 全局变量等, 所以也可以包含FunctionPass的功能), AnalysePass主要做性能测试/压力测试/调优/分析/日志等.</p>
<ul>
<li>一个项目由多个Module构成, 一个Module约等于一个存在函数实体的文件, 头文件或者被包含的文件不算</li>
<li>一个Module由多个Function/GlobalVariable/GlobalAlias/GlobalIFunc/NamedMDNode构成, 前两个最常用</li>
<li>一个Function由多个BasicBlock构成, 继承过程: Function - GlobalObject - GlobalValue - Constant - User - Value</li>
<li>一个BasicBlock由多个Instruction构成, 每个BasicBlock都有一个结束指令, 继承过程: BasicBlock - Value</li>
<li>一个Instruction即为一条IR指令, 最终会编译为一条或多条汇编指令, 继承过程: Instruction - User - Value</li>
<li>GlobalVariable继承过程: GlobalVariable - GlobalObject - GlobalValue - Constant - User - Value</li>
</ul>
<p>什么情况下使用LLVM Pass?
  如第一篇所述, LLVM衍生出众多编译器前端, 如clang, swiftc, rustc等. 目前第三方代码嵌入LLVM有如下三种方式:</p>
<ul>
<li>动态Pass方式, 前端运行时动态加载Pass, 开发成本最低</li>
<li>静态Pass方式, 编译时静态链接Pass</li>
<li>修改LLVM源码强行嵌入, 是大部分Ollvm采用的方式; 如果编译器前端不支持Pass则是唯一选择</li>
</ul>
<p>AppleClang的Pass
  AppleClang, 即XCode自带的Clang, 苹果因为安全性考虑阉割掉了LLVM Pass, 因此常规方法并不能加载起来.
当然如果如果逆向技术过关, 也很容易将Pass改为兼容AppleClang的.</p>
<h3 id="编码">编码</h3>
<p>  只需要<code>demo.cpp</code>和<code>CMakeLists.txt</code>两个文件. 因为LLVM的版本较多, 网上开源的LLVM Pass项目只支持部分版本, 笔者根据刚学习的CMake将其改造为兼容LLVM8-18.</p>
<p>项目地址:<a href="https://github.com/lich4/llvm-pass-hikari">https://github.com/lich4/llvm-pass-hikari</a></p>
<p>demo.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>#include &#34;llvm/IR/LegacyPassManager.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Pass.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Passes/PassBuilder.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Passes/PassPlugin.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Support/raw_ostream.h&#34;
</span></span><span style="display:flex;"><span>#if LLVM_VERSION_MAJOR &lt;= 15
</span></span><span style="display:flex;"><span>#include &#34;llvm/Transforms/IPO/PassManagerBuilder.h&#34;
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#include &#34;llvm/IRReader/IRReader.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Transforms/Utils/Cloning.h&#34;
</span></span><span style="display:flex;"><span><span style="color:#ec0000">using</span> <span style="color:#ec0000">namespace</span> llvm;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#include &lt;iostream&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#define PASSNAME          &#34;MyPassDemo&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#if LLVM_VERSION_MAJOR &lt;= 13
</span></span><span style="display:flex;"><span>#define getPtElemType getPointerElementType
</span></span><span style="display:flex;"><span>#else
</span></span><span style="display:flex;"><span>#define getPtElemType getNonOpaquePointerElementType
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// ---------------- Legacy Pass ---------------- //
</span></span><span style="display:flex;"><span><span style="color:#ec0000">class</span> <span style="color:#5f5fff">MyPassDemoLegacy</span> <span style="color:#ec0000">:</span> <span style="color:#ec0000">public</span> FunctionPass {
</span></span><span style="display:flex;"><span><span style="color:#ec0000">public</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">static</span> <span style="color:#5f5fff">char</span> ID;
</span></span><span style="display:flex;"><span>    MyPassDemoLegacy() <span style="color:#ec0000">:</span> FunctionPass(ID) {}
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">virtual</span> <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">runOnFunction</span>(Function<span style="color:#ec0000">&amp;</span> F) <span style="color:#ec0000">override</span> {
</span></span><span style="display:flex;"><span>        errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;MyPassDemoLegacy</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">char</span> MyPassDemoLegacy<span style="color:#ec0000">::</span>ID <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>#if LLVM_VERSION_MAJOR &lt;= 15
</span></span><span style="display:flex;"><span><span style="color:#ec0000">static</span> RegisterStandardPasses <span style="color:#5f5fff">RegisterMyPass</span>(PassManagerBuilder<span style="color:#ec0000">::</span>EP_EarlyAsPossible, 
</span></span><span style="display:flex;"><span>    [](<span style="color:#ec0000">const</span> PassManagerBuilder <span style="color:#ec0000">&amp;</span>, legacy<span style="color:#ec0000">::</span>PassManagerBase <span style="color:#ec0000">&amp;</span>PM) {
</span></span><span style="display:flex;"><span>        PM.add(<span style="color:#ec0000">new</span> MyPassDemoLegacy());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>#else
</span></span><span style="display:flex;"><span><span style="color:#ec0000">static</span> RegisterPass<span style="color:#ec0000">&lt;</span>MyPassDemoLegacy<span style="color:#ec0000">&gt;</span> RegisterMyPass(PASSNAME, PASSNAME, <span style="color:#ec0000">false</span>, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>// ---------------- Legacy Pass ---------------- //
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// ---------------- New Pass ---------------- //
</span></span><span style="display:flex;"><span>#if LLVM_VERSION_MAJOR &lt;= 13
</span></span><span style="display:flex;"><span>#define OptimizationLevel PassBuilder::OptimizationLevel
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">class</span> <span style="color:#5f5fff">MyPassDemo</span> <span style="color:#ec0000">:</span> <span style="color:#ec0000">public</span> PassInfoMixin<span style="color:#ec0000">&lt;</span>MyPassDemo<span style="color:#ec0000">&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#ec0000">public</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>    PreservedAnalyses run(Module <span style="color:#ec0000">&amp;</span>M, ModuleAnalysisManager <span style="color:#ec0000">&amp;</span>AM) {
</span></span><span style="display:flex;"><span>        errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;MyPassDemo</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">return</span> PreservedAnalyses<span style="color:#ec0000">::</span>all();
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">static</span> <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">isRequired</span>() { <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">extern</span> <span style="color:#008900">&#34;C&#34;</span> LLVM_ATTRIBUTE_WEAK <span style="color:#ec0000">::</span>llvm<span style="color:#ec0000">::</span>PassPluginLibraryInfo llvmGetPassPluginInfo() {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> {
</span></span><span style="display:flex;"><span>        .APIVersion <span style="color:#ec0000">=</span> LLVM_PLUGIN_API_VERSION,
</span></span><span style="display:flex;"><span>        .PluginName <span style="color:#ec0000">=</span> PASSNAME,
</span></span><span style="display:flex;"><span>        .PluginVersion <span style="color:#ec0000">=</span> <span style="color:#008900">&#34;1.0&#34;</span>,
</span></span><span style="display:flex;"><span>        .RegisterPassBuilderCallbacks <span style="color:#ec0000">=</span> [](PassBuilder <span style="color:#ec0000">&amp;</span>PB) {
</span></span><span style="display:flex;"><span>            PB.registerPipelineStartEPCallback(
</span></span><span style="display:flex;"><span>                [](ModulePassManager <span style="color:#ec0000">&amp;</span>MPM
</span></span><span style="display:flex;"><span>#if LLVM_VERSION_MAJOR &gt;= 12
</span></span><span style="display:flex;"><span>                , OptimizationLevel Level
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>                ) {
</span></span><span style="display:flex;"><span>                    MPM.addPass(MyPassDemo());
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>            PB.registerPipelineParsingCallback(
</span></span><span style="display:flex;"><span>                [](StringRef Name, ModulePassManager<span style="color:#ec0000">&amp;</span> MPM, ArrayRef<span style="color:#ec0000">&lt;</span>PassBuilder<span style="color:#ec0000">::</span>PipelineElement<span style="color:#ec0000">&gt;</span>) {
</span></span><span style="display:flex;"><span>                    MPM.addPass(MyPassDemo());
</span></span><span style="display:flex;"><span>                    <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>// ---------------- New Pass ---------------- //
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>__attribute__((constructor)) <span style="color:#5f5fff">void</span> onInit() {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#008900">&#34;MyPassDemo onInit</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span><span style="color:#ec0000">cmake_minimum_required</span>(<span style="color:#008900">VERSION</span> <span style="color:#008900">3.6</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">project</span>(<span style="color:#008900">MyPassDemo</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">set</span>(<span style="color:#008900">CMAKE_CXX_STANDARD</span> <span style="color:#008900">17</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">set</span>(<span style="color:#008900">CMAKE_BUILD_TYPE</span> <span style="color:#008900">&#34;Debug&#34;</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">find_package</span>(<span style="color:#008900">LLVM</span> <span style="color:#008900">REQUIRED</span> <span style="color:#008900">CONFIG</span>)            # LLVMConfig.cmake初始化环境
</span></span><span style="display:flex;"><span><span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">list</span>(<span style="color:#008900">APPEND</span> <span style="color:#008900">CMAKE_MODULE_PATH</span> <span style="color:#008900">&#34;${LLVM_DIR}&#34;</span>)  # 兼容LLVM&lt;=13
</span></span><span style="display:flex;"><span><span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">include</span>(<span style="color:#008900">AddLLVM</span>)                              # 导入add_llvm_pass_plugin函数
</span></span><span style="display:flex;"><span><span style="color:#ec0000">include</span>(<span style="color:#008900">HandleLLVMOptions</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">add_definitions</span>(<span style="color:#ec0000">${</span><span style="color:#ec0000">LLVM_DEFINITIONS</span><span style="color:#ec0000">}</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">include_directories</span>(<span style="color:#ec0000">${</span><span style="color:#ec0000">LLVM_INCLUDE_DIRS</span><span style="color:#ec0000">}</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">link_directories</span>(<span style="color:#ec0000">${</span><span style="color:#ec0000">LLVM_LIBRARY_DIRS</span><span style="color:#ec0000">}</span>) <span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">if</span>(<span style="color:#008900">NOT</span> <span style="color:#008900">COMMAND</span> <span style="color:#008900">add_llvm_pass_plugin</span>)          # 兼容LLVM&lt;=9
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">message</span>(<span style="color:#008900">WARNING</span> <span style="color:#008900">&#34;add_llvm_pass_plugin not exist&#34;</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span>  <span style="color:#ec0000">function</span>(<span style="color:#008900">add_llvm_pass_plugin</span> <span style="color:#008900">name</span>)         <span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span>    <span style="color:#ec0000">cmake_parse_arguments</span>(<span style="color:#008900">ARG</span> <span style="color:#008900">&#34;NO_MODULE&#34;</span> <span style="color:#008900">&#34;SUBPROJECT&#34;</span> <span style="color:#008900">&#34;&#34;</span> <span style="color:#ec0000">${</span><span style="color:#ec0000">ARGN</span><span style="color:#ec0000">}</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span>    <span style="color:#ec0000">set</span>(<span style="color:#008900">link_into_tools_default</span> <span style="color:#008900">OFF</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span>    <span style="color:#ec0000">add_llvm_library</span>(<span style="color:#ec0000">${</span><span style="color:#ec0000">name</span><span style="color:#ec0000">}</span> <span style="color:#008900">MODULE</span> <span style="color:#ec0000">${</span><span style="color:#ec0000">ARG_UNPARSED_ARGUMENTS</span><span style="color:#ec0000">}</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span>    <span style="color:#ec0000">message</span>(<span style="color:#008900">STATUS</span> <span style="color:#008900">&#34;Registering ${name} as a pass plugin (static build: ${LLVM_${name_upper}_LINK_INTO_TOOLS})&#34;</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span>  <span style="color:#ec0000">endfunction</span>(<span style="color:#008900">add_llvm_pass_plugin</span>)<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">endif</span>()<span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000">
</span></span></span><span style="display:flex;"><span><span style="color:#ec0000"></span><span style="color:#ec0000">add_llvm_pass_plugin</span>(<span style="color:#008900">MyPassDemo</span><span style="color:#ec0000">${</span><span style="color:#ec0000">LLVM_VERSION_MAJOR</span><span style="color:#ec0000">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#008900">demo.cpp</span>
</span></span><span style="display:flex;"><span>)<span style="color:#ec0000">
</span></span></span></code></pre></div><h3 id="测试">测试</h3>
<p>编译:</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ec0000">export</span> <span style="color:#ec0000">LLVM_DIR</span><span style="color:#ec0000">=</span>/path/to/llvm12/build/lib/cmake/llvm
</span></span><span style="display:flex;"><span>cmake -B build --fresh
</span></span><span style="display:flex;"><span>cmake --build build
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>llvm12/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -Xclang -load -Xclang build/MyPassDemo12.dylib /tmp/1.cpp
</span></span><span style="display:flex;"><span># for LLVM&lt;=12      Legacy Pass (等价于上面)
</span></span><span style="display:flex;"><span>llvm12/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -fplugin<span style="color:#ec0000">=</span>build/MyPassDemo12.dylib /tmp/1.cpp
</span></span><span style="display:flex;"><span># for LLVM=9/10/11 New Pass (O3生效)
</span></span><span style="display:flex;"><span>llvm11/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -fexperimental-new-pass-manager -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo11.dylib /tmp/1.cpp -O3
</span></span><span style="display:flex;"><span># for LLVM=12      New Pass
</span></span><span style="display:flex;"><span>llvm12/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -fexperimental-new-pass-manager -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo12.dylib /tmp/1.cpp
</span></span><span style="display:flex;"><span># for LLVM=13/14    Legacy Pass
</span></span><span style="display:flex;"><span>llvm13/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -flegacy-pass-manager -fplugin<span style="color:#ec0000">=</span>build/MyPassDemo13.dylib /tmp/1.cpp
</span></span><span style="display:flex;"><span># for LLVM=13/14    New Pass
</span></span><span style="display:flex;"><span>llvm13/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo13.dylib /tmp/1.cpp
</span></span><span style="display:flex;"><span># for LLVM&gt;=15      New Pass
</span></span><span style="display:flex;"><span>llvm15/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo15.dylib /tmp/1.cpp
</span></span></code></pre></div><p>opt支持ll需要llvm&gt;=15</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>llvm15/build/bin/opt --O3 -S -o /tmp/test_new.ll /tmp/test.ll 
</span></span><span style="display:flex;"><span>llvm15/build/bin/opt -load-pass-plugin build/MyPassDemo15.dylib -passes all -S -o /tmp/test_new.ll /tmp/test.ll 
</span></span></code></pre></div><p>经过测试可以发现, Pass的LLVM版本需要和LLVM大版本一致, 否则也会产生错误, 但总体来说Pass解决了LLVM编译代码量过大的问题, 所以仍然值得采用, 测试结果:
<code>hello MyPassDemo</code></p>
<h3 id="pass加载时机">Pass加载时机</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// EP_Peephole                  PeepholeEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerPeepholeEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(FunctionPassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// EP_LoopOptimizerEnd          LateLoopOptimizationsEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerLateLoopOptimizationsEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(LoopPassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// EP_LateLoopOptimizations     LoopOptimizerEndEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerLoopOptimizerEndEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(LoopPassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// EP_ScalarOptimizerLate       ScalarOptimizerLateEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerScalarOptimizerLateEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(FunctionPassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// EP_CGSCCOptimizerLate        CGSCCOptimizerLateEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerCGSCCOptimizerLateEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(CGSCCPassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// EP_VectorizerStart           VectorizerStartEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerVectorizerStartEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(FunctionPassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// EP_EarlyAsPossible           PipelineStartEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerPipelineStartEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(ModulePassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// EP_ModuleOptimizerEarly      PipelineEarlySimplificationEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerPipelineEarlySimplificationEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(ModulePassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// 
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerOptimizerEarlyEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(ModulePassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>// EP_OptimizerLast             OptimizerLastEPCallbacks
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerOptimizerLastEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(ModulePassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>//
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerFullLinkTimeOptimizationEarlyEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(ModulePassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span><span style="display:flex;"><span>//
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">registerFullLinkTimeOptimizationLastEPCallback</span>(<span style="color:#ec0000">const</span> std<span style="color:#ec0000">::</span>function<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">void</span>(ModulePassManager<span style="color:#ec0000">&amp;</span>, OptimizationLevel)<span style="color:#ec0000">&gt;&amp;</span>);
</span></span></code></pre></div><p>使用helloworld测试EP顺序:</p>
<ul>
<li>Debug: PipelineStart -&gt; PipelineEarlySimplification -&gt; OptimizerLast</li>
<li>Release: PipelineStart -&gt; PipelineEarlySimplification -&gt; Peephole -&gt; Peephole -&gt; Peephole -&gt; ScalarOptimizerLate -&gt; Peephole -&gt; VectorizerStart -&gt; OptimizerLast</li>
</ul>
<h2 id="ollvm">OLLVM</h2>
<h3 id="现存ollvm项目汇总">现存OLLVM项目汇总</h3>
<p>  之前提到LLVM的架构优于Gcc, 因此可以在其上可以更好的实现编译器层级的代码混淆. 这就是ollvm(obfuscated-llvm). 笔者第一次接触到ollvm是在2017年做漏洞挖掘的时候. 下图为写这篇文章时现存的开源ollvm项目</p>
<p>










<figure class="">

    <div>
        <img loading="lazy" alt="" src=" /img/ollvm1.png">
    </div>

    
</figure></p>
<ul>
<li>最早的OLLVM <a href="https://github.com/obfuscator-llvm/obfuscator">https://github.com/obfuscator-llvm/obfuscator</a></li>
</ul>
<blockquote>
<p>  瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目, 支持LLVM3.3-4.0. 之后出现呢的所有ollvm项目均基于该项目开发. 该项目首次提出LLVM方式进行“控制流伪造”(BCF),“控制流平坦化”(FLA),“指令替换”(SUB)的代码混淆方式.</p>
</blockquote>
<ul>
<li>Hikari <a href="https://github.com/HikariObfuscator/Hikari">https://github.com/HikariObfuscator/Hikari</a></li>
</ul>
<blockquote>
<p>2018年开始的Ollvm项目, 支持LLVM6.0-8.0, 与obfuscator相比增加了如下功能:</p>
<ul>
<li>OC混淆, 混淆Objective-C类名及selector, 防止你优雅的逆向, 看一眼函数就知道干嘛的了</li>
<li>函数包装, 将一个函数调用变成深层嵌套函数, 功能不强, 可以恶心一些小白</li>
<li>字符串加密, 通过异或的方式加密字符串到数据区, 首次使用时解密</li>
<li>间接分支, 将跳转地址改为跳转寄存器, 大大增强FLA难度</li>
<li>拆分基本块, 功能也很强, 但容易产生崩溃</li>
<li>函数调用混淆, 把函数调用改成dlopen+dlsym的动态调用</li>
</ul>
</blockquote>
<ul>
<li>Hikari-LLVM15 <a href="https://github.com/61bcdefg/Hikari-LLVM15">https://github.com/61bcdefg/Hikari-LLVM15</a></li>
</ul>
<blockquote>
<p>2022年开始的替代Hikari的项目, Hikari原作者不开发了. 支持LLVM15+, 与Hikari相比增加了如下功能:</p>
<ul>
<li>支持Swift</li>
<li>反调试</li>
<li>反Hook</li>
<li>常量加密</li>
<li>支持arm64e</li>
</ul>
</blockquote>
<ul>
<li>Pluto <a href="https://github.com/bluesadi/Pluto">https://github.com/bluesadi/Pluto</a></li>
</ul>
<blockquote>
<p>2021年开始的Ollvm项目, 支持LLVM14, 与obfuscator相比增加了如下功能:</p>
<ul>
<li>增强的FLA</li>
<li>增强BCF为“随机控制流”(RCF)</li>
<li>反Angr, Angr是一种利用符号执行动态分析Ollvm的方式</li>
<li>MBA(Mixed Boolean-Arithmetic)混淆, 将一个常量表达式用一系列运算代替, 算伪造指令流, 但比花指令高级多了</li>
</ul>
<p>混合布尔算术(Mixed Boolean Arithmetic)是2007年提出的一种混淆算法, 这种算法由算数运算(例如ADD/SUB/MUL)和布尔运算(例如AND/OR/NOT)的混合使用组成</p>
</blockquote>
<ul>
<li>goron <a href="https://github.com/amimo/goron">https://github.com/amimo/goron</a></li>
</ul>
<blockquote>
<p>2019年开始的Ollvm项目, 支持LLVM7/8/9/10, 与obfuscator相比增加了如下功能:</p>
<ul>
<li>间接调用, 将引用的函数地址变换后存到数据区, 再动态调用</li>
<li>间接全局变量, 将引用的变量地址变换后存到数据区, 再动态调用</li>
</ul>
</blockquote>
<ul>
<li>Arkari <a href="https://github.com/KomiMoe/Arkari">https://github.com/KomiMoe/Arkari</a></li>
</ul>
<blockquote>
<p>2022年开始的基于goron的项目, goron原作者不开发了. 支持LLVM14+, 功能和goron一致</p>
</blockquote>
<ul>
<li>xVMP <a href="https://github.com/GANGE666/xVMP">https://github.com/GANGE666/xVMP</a></li>
</ul>
<blockquote>
<p>用LLVM实现的VMP, 支持LLVM8, 只支持Debug不支持Release</p>
</blockquote>
<ul>
<li>其他Ollvm</li>
</ul>
<blockquote>
<p><a href="https://github.com/DeNA/DeClang">https://github.com/DeNA/DeClang</a>, 用于Swift混淆, 不支持C++<br>
<a href="https://github.com/open-obfuscator/o-mvll">https://github.com/open-obfuscator/o-mvll</a>, 基于LLVMPass, 支持Python, 扩展性较强<br>
<a href="https://github.com/25077667/VMPilot">https://github.com/25077667/VMPilot</a>, 也是基于LLVM的VMP</p>
</blockquote>
<p>  关于基于Ollvm的VMP, iOS上因为有内存保护, 非越狱无法动态更改指令, 因此iOS上的VMP只能沦为IR解释器, 因此其解密难度比Lua/JS等解释器低得多. 所以还不如用跨语言方式去增加整体复杂度.</p>
<p>  就跨平台兼容性和稳定性而言, 原版Ollvm &gt; Hikari &gt; 其他Ollvm, 这里的不稳定指的是编译失败, 或运行时未达到混淆目的, 或运行时因为混淆导致问题; 就功能而言, Hikari &gt; 原版Ollvm, 其他Ollvm各有特色. 可以根据自己实际情况使用</p>
<h3 id="混淆控制方式">混淆控制方式</h3>
<h4 id="简介-1">简介</h4>
<p>  在很多实际项目中, 由于以下原因无法对整个项目完全混淆, 实际操作时, 常常需要根据业务敏感程度使用不同程度的混淆, 比如攻防模块多用一些混淆:</p>
<ul>
<li>项目较大, 依赖较多, 或使用了很多header-only的库, 混淆了很多不需要混淆的代码, 导致编译出来的二进制过大</li>
<li>项目较大, 依赖较多, 使用了平坦化(或其他方式)混淆了很多不需要混淆的代码, 导致编译极其缓慢, Ollvm比较耗内存</li>
<li>混淆了复杂算法, 导致运行时耗时比正常大很多, 一般使用平坦化后耗时会增加10%以上</li>
<li>混淆过多可能不允许上架AppStore, GooglePlay等</li>
</ul>
<p>  不同的Ollvm采用的方式大同小异, 无非是以下几种:</p>
<ul>
<li>对需要混淆的模块单独指定命令行参数, 如<code>-mllvm -fla</code>, 这种方式兼容所有支持llvm命令行参数的编译器前端</li>
<li>使用环境变量指定混淆参数</li>
<li>对需要混淆的函数指定注解, 如<code>__attribute__((__annotate__((&quot;fla&quot;))))</code>(新式语法<code>[[clang::annotate(&quot;fla&quot;)]]</code>), 这种方式仅支持C/C++, Objective-C和其他语言均不支持</li>
<li>对需要混淆的函数指定标记函数, 如下所示, 这种方式支持Objective-C</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ObjectiveC" data-lang="ObjectiveC"><span style="display:flex;"><span><span style="color:#ec0000">extern</span> <span style="color:#5f5fff">void</span> <span style="color:#5f5fff">hikari_fla</span>(<span style="color:#5f5fff">void</span>);
</span></span><span style="display:flex;"><span><span style="color:#ec0000">@implementation</span> <span style="color:#5f5fff">foo2</span>:<span style="color:#5f5fff">NSObject</span>
</span></span><span style="display:flex;"><span>+(<span style="color:#5f5fff">void</span>)<span style="color:#5f5fff">foo</span>{
</span></span><span style="display:flex;"><span>  hikari_fla();
</span></span><span style="display:flex;"><span>  NSLog(<span style="color:#008900">@&#34;FOOOO2&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ec0000">@end</span>
</span></span></code></pre></div><ul>
<li>使用配置文件来指定需要混淆的函数和模块, 这种方式兼容所有编译器前端, 用于解决前几种方式搞不定的情况</li>
</ul>
<h4 id="现存控制方式">现存控制方式</h4>
<ul>
<li>命令行参数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ec0000">static</span> cl<span style="color:#ec0000">::</span>opt<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">bool</span><span style="color:#ec0000">&gt;</span> EnableFlattening(<span style="color:#008900">&#34;enable-cffobf&#34;</span>, cl<span style="color:#ec0000">::</span>init(<span style="color:#ec0000">false</span>),
</span></span><span style="display:flex;"><span>                                      cl<span style="color:#ec0000">::</span>NotHidden,
</span></span><span style="display:flex;"><span>                                      cl<span style="color:#ec0000">::</span>desc(<span style="color:#008900">&#34;Enable Flattening.&#34;</span>));
</span></span></code></pre></div><ul>
<li>函数注解</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#ec0000">::</span>string readAnnotate(Function <span style="color:#ec0000">*</span>f) {
</span></span><span style="display:flex;"><span>  std<span style="color:#ec0000">::</span>string annotation <span style="color:#ec0000">=</span> <span style="color:#008900">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Get annotation variable
</span></span><span style="display:flex;"><span>  GlobalVariable <span style="color:#ec0000">*</span>glob <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>      f<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getGlobalVariable(<span style="color:#008900">&#34;llvm.global.annotations&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> (glob <span style="color:#ec0000">!=</span> <span style="color:#ec0000">NULL</span>) {
</span></span><span style="display:flex;"><span>    // Get the array
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (ConstantArray <span style="color:#ec0000">*</span>ca <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantArray<span style="color:#ec0000">&gt;</span>(glob<span style="color:#ec0000">-&gt;</span>getInitializer())) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> ca<span style="color:#ec0000">-&gt;</span>getNumOperands(); <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>        // Get the struct
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (ConstantStruct <span style="color:#ec0000">*</span>cs <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantStruct<span style="color:#ec0000">&gt;</span>(ca<span style="color:#ec0000">-&gt;</span>getOperand(i))) {
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (ConstantExpr <span style="color:#ec0000">*</span>expr <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantExpr<span style="color:#ec0000">&gt;</span>(cs<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>))) {
</span></span><span style="display:flex;"><span>            // If it&#39;s a bitcast we can check if the annotation is concerning
</span></span><span style="display:flex;"><span>            // the current function
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (expr<span style="color:#ec0000">-&gt;</span>getOpcode() <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>BitCast <span style="color:#ec0000">&amp;&amp;</span> expr<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>) <span style="color:#ec0000">==</span> f) {
</span></span><span style="display:flex;"><span>              ConstantExpr <span style="color:#ec0000">*</span>note <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ConstantExpr<span style="color:#ec0000">&gt;</span>(cs<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>));
</span></span><span style="display:flex;"><span>              // If it&#39;s a GetElementPtr, that means we found the variable
</span></span><span style="display:flex;"><span>              // containing the annotations
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">if</span> (note<span style="color:#ec0000">-&gt;</span>getOpcode() <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>GetElementPtr) {
</span></span><span style="display:flex;"><span>                <span style="color:#ec0000">if</span> (GlobalVariable <span style="color:#ec0000">*</span>annoteStr <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                        dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(note<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>))) {
</span></span><span style="display:flex;"><span>                  <span style="color:#ec0000">if</span> (ConstantDataSequential <span style="color:#ec0000">*</span>data <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                          dyn_cast<span style="color:#ec0000">&lt;</span>ConstantDataSequential<span style="color:#ec0000">&gt;</span>(
</span></span><span style="display:flex;"><span>                              annoteStr<span style="color:#ec0000">-&gt;</span>getInitializer())) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ec0000">if</span> (data<span style="color:#ec0000">-&gt;</span>isString()) {
</span></span><span style="display:flex;"><span>                      annotation <span style="color:#ec0000">+=</span> data<span style="color:#ec0000">-&gt;</span>getAsString().lower() <span style="color:#ec0000">+</span> <span style="color:#008900">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                  }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>              }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> annotation;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>标记函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">readFlag</span>(Function <span style="color:#ec0000">*</span>f, std<span style="color:#ec0000">::</span>string attribute) {
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">for</span> (inst_iterator I <span style="color:#ec0000">=</span> inst_begin(f); I <span style="color:#ec0000">!=</span> inst_end(f); I<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>    Instruction <span style="color:#ec0000">*</span>Inst <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;*</span>I;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (CallInst <span style="color:#ec0000">*</span>CI <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>CallInst<span style="color:#ec0000">&gt;</span>(Inst)) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (CI<span style="color:#ec0000">-&gt;</span>getCalledFunction() <span style="color:#ec0000">!=</span> <span style="color:#ec0000">nullptr</span> <span style="color:#ec0000">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>          CI<span style="color:#ec0000">-&gt;</span>getCalledFunction()<span style="color:#ec0000">-&gt;</span>getName().contains(<span style="color:#008900">&#34;hikari_&#34;</span> <span style="color:#ec0000">+</span> attribute)) {
</span></span><span style="display:flex;"><span>        CI<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="控制编译器优化">控制编译器优化</h4>
<p>  由于现代编译器的卓越能力, 一些混淆手段很可能在Release下被还原导致实际未混淆, 这种情况下Ollvm项目以Debug编译反而能达到效果, 而笔者认为正确的解决方式为, 在静态区构造特殊数据, 用于关联待混淆常量及函数, 并将特殊数据指定为used避免被优化. 以下是Clang支持的针对函数和变量优化的语法, 对函数关闭优化可以同时防止内联, 对变量关闭优化可以防止其被优化成常量.</p>
<ul>
<li><code>__attribute__((optnone))</code> 对函数关闭优化 (如果是Gcc可以指定优化等级)</li>
<li><code>#pragma clang optimize off</code> <code>#pragma clang optimize on</code> 对区间内的函数关闭优化</li>
<li><code>volatile</code> 对变量关闭优化</li>
<li><code>__attribute__((used))</code> 对全局变量关闭优化</li>
</ul>
<h2 id="常量加密">常量加密</h2>
<h3 id="hikari-stringencryption模块分析">Hikari StringEncryption模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#5f5fff">void</span> <span style="color:#5f5fff">HandleFunction</span>(Function <span style="color:#ec0000">*</span>Func) {
</span></span><span style="display:flex;"><span>    FixFunctionConstantExpr(Func);
</span></span><span style="display:flex;"><span>    set<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*&gt;</span> Globals;
</span></span><span style="display:flex;"><span>    set<span style="color:#ec0000">&lt;</span>User <span style="color:#ec0000">*&gt;</span> Users;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">BB</span> : <span style="color:#ec0000">*</span>Func) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (Instruction <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">I</span> : BB) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (Value <span style="color:#ec0000">*</span><span style="color:#ec0000">Op</span> : I.operands()) {
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (GlobalVariable <span style="color:#ec0000">*</span>G <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(Op<span style="color:#ec0000">-&gt;</span>stripPointerCasts())) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span>(User<span style="color:#ec0000">*</span> U<span style="color:#ec0000">=</span>dyn_cast<span style="color:#ec0000">&lt;</span>User<span style="color:#ec0000">&gt;</span>(Op)){
</span></span><span style="display:flex;"><span>              Users.insert(U);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Users.insert(<span style="color:#ec0000">&amp;</span>I);
</span></span><span style="display:flex;"><span>            Globals.insert(G);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    set<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*&gt;</span> rawStrings;
</span></span><span style="display:flex;"><span>    set<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*&gt;</span> objCStrings;
</span></span><span style="display:flex;"><span>    map<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span>, pair<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*</span>, GlobalVariable <span style="color:#ec0000">*&gt;&gt;</span> GV2Keys;
</span></span><span style="display:flex;"><span>    map<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span> /*old*/, pair<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span> /*encrypted*/, GlobalVariable <span style="color:#ec0000">*</span> /*decrypt space*/<span style="color:#ec0000">&gt;&gt;</span> old2new;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (GlobalVariable <span style="color:#ec0000">*</span><span style="color:#ec0000">GV</span> : Globals) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (GV<span style="color:#ec0000">-&gt;</span>hasInitializer() <span style="color:#ec0000">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getSection() <span style="color:#ec0000">!=</span> StringRef(<span style="color:#008900">&#34;llvm.metadata&#34;</span>) <span style="color:#ec0000">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getSection().find(StringRef(<span style="color:#008900">&#34;__objc&#34;</span>)) <span style="color:#ec0000">==</span> string<span style="color:#ec0000">::</span>npos <span style="color:#ec0000">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getName().find(<span style="color:#008900">&#34;OBJC&#34;</span>) <span style="color:#ec0000">==</span> string<span style="color:#ec0000">::</span>npos) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (GV<span style="color:#ec0000">-&gt;</span>getInitializer()<span style="color:#ec0000">-&gt;</span>getType() <span style="color:#ec0000">==</span>
</span></span><span style="display:flex;"><span>            Func<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getTypeByName(<span style="color:#008900">&#34;struct.__NSConstantString_tag&#34;</span>)) {
</span></span><span style="display:flex;"><span>          objCStrings.insert(GV);
</span></span><span style="display:flex;"><span>          rawStrings.insert(
</span></span><span style="display:flex;"><span>              cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(cast<span style="color:#ec0000">&lt;</span>ConstantStruct<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getInitializer())
</span></span><span style="display:flex;"><span>                                       <span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">2</span>)
</span></span><span style="display:flex;"><span>                                       <span style="color:#ec0000">-&gt;</span>stripPointerCasts()));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        } <span style="color:#ec0000">else</span> <span style="color:#ec0000">if</span> (isa<span style="color:#ec0000">&lt;</span>ConstantDataSequential<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getInitializer())) {
</span></span><span style="display:flex;"><span>          rawStrings.insert(GV);
</span></span><span style="display:flex;"><span>        }<span style="color:#ec0000">else</span> <span style="color:#ec0000">if</span>(isa<span style="color:#ec0000">&lt;</span>ConstantArray<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getInitializer())){
</span></span><span style="display:flex;"><span>           ConstantArray<span style="color:#ec0000">*</span> CA<span style="color:#ec0000">=</span>cast<span style="color:#ec0000">&lt;</span>ConstantArray<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getInitializer());
</span></span><span style="display:flex;"><span>           <span style="color:#ec0000">for</span>(<span style="color:#5f5fff">unsigned</span> i<span style="color:#ec0000">=</span><span style="color:#008900">0</span>;i<span style="color:#ec0000">&lt;</span>CA<span style="color:#ec0000">-&gt;</span>getNumOperands();i<span style="color:#ec0000">++</span>){
</span></span><span style="display:flex;"><span>             Value<span style="color:#ec0000">*</span> op<span style="color:#ec0000">=</span>CA<span style="color:#ec0000">-&gt;</span>getOperand(i)<span style="color:#ec0000">-&gt;</span>stripPointerCasts();
</span></span><span style="display:flex;"><span>             <span style="color:#ec0000">if</span>(GlobalVariable<span style="color:#ec0000">*</span> GV<span style="color:#ec0000">=</span>dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(op)){
</span></span><span style="display:flex;"><span>               Globals.insert(GV);
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>           }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (GlobalVariable <span style="color:#ec0000">*</span><span style="color:#ec0000">GV</span> : rawStrings) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (GV<span style="color:#ec0000">-&gt;</span>getInitializer()<span style="color:#ec0000">-&gt;</span>isZeroValue() <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getInitializer()<span style="color:#ec0000">-&gt;</span>isNullValue()) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      ConstantDataSequential <span style="color:#ec0000">*</span>CDS <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          cast<span style="color:#ec0000">&lt;</span>ConstantDataSequential<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getInitializer());
</span></span><span style="display:flex;"><span>      Type <span style="color:#ec0000">*</span>memberType <span style="color:#ec0000">=</span> CDS<span style="color:#ec0000">-&gt;</span>getElementType();
</span></span><span style="display:flex;"><span>      // Ignore non-IntegerType
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>isa<span style="color:#ec0000">&lt;</span>IntegerType<span style="color:#ec0000">&gt;</span>(memberType)) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      IntegerType <span style="color:#ec0000">*</span>intType <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>IntegerType<span style="color:#ec0000">&gt;</span>(memberType);
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>KeyConst <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>EncryptedConst <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>DummyConst <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (intType <span style="color:#ec0000">==</span> Type<span style="color:#ec0000">::</span>getInt8Ty(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext())) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint8_t</span><span style="color:#ec0000">&gt;</span> keys;
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint8_t</span><span style="color:#ec0000">&gt;</span> encry;
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint8_t</span><span style="color:#ec0000">&gt;</span> dummy;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> CDS<span style="color:#ec0000">-&gt;</span>getNumElements(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#5f5fff">uint8_t</span> K <span style="color:#ec0000">=</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint8_t();
</span></span><span style="display:flex;"><span>          <span style="color:#5f5fff">uint64_t</span> V <span style="color:#ec0000">=</span> CDS<span style="color:#ec0000">-&gt;</span>getElementAsInteger(i);
</span></span><span style="display:flex;"><span>          keys.push_back(K);
</span></span><span style="display:flex;"><span>          encry.push_back(K <span style="color:#ec0000">^</span> V);
</span></span><span style="display:flex;"><span>          dummy.push_back(rand());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        KeyConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                          ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint8_t</span><span style="color:#ec0000">&gt;</span>(keys));
</span></span><span style="display:flex;"><span>        EncryptedConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                                ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint8_t</span><span style="color:#ec0000">&gt;</span>(encry));
</span></span><span style="display:flex;"><span>        DummyConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                                ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint8_t</span><span style="color:#ec0000">&gt;</span>(dummy));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> <span style="color:#ec0000">if</span> (intType <span style="color:#ec0000">==</span> Type<span style="color:#ec0000">::</span>getInt16Ty(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext())) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint16_t</span><span style="color:#ec0000">&gt;</span> keys;
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint16_t</span><span style="color:#ec0000">&gt;</span> encry;
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint16_t</span><span style="color:#ec0000">&gt;</span> dummy;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> CDS<span style="color:#ec0000">-&gt;</span>getNumElements(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#5f5fff">uint16_t</span> K <span style="color:#ec0000">=</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint16_t();
</span></span><span style="display:flex;"><span>          <span style="color:#5f5fff">uint64_t</span> V <span style="color:#ec0000">=</span> CDS<span style="color:#ec0000">-&gt;</span>getElementAsInteger(i);
</span></span><span style="display:flex;"><span>          keys.push_back(K);
</span></span><span style="display:flex;"><span>          encry.push_back(K <span style="color:#ec0000">^</span> V);
</span></span><span style="display:flex;"><span>          dummy.push_back(rand());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        KeyConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                          ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint16_t</span><span style="color:#ec0000">&gt;</span>(keys));
</span></span><span style="display:flex;"><span>        EncryptedConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                                ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint16_t</span><span style="color:#ec0000">&gt;</span>(encry));
</span></span><span style="display:flex;"><span>        DummyConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                                ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint16_t</span><span style="color:#ec0000">&gt;</span>(dummy));
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> <span style="color:#ec0000">if</span> (intType <span style="color:#ec0000">==</span> Type<span style="color:#ec0000">::</span>getInt32Ty(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext())) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint32_t</span><span style="color:#ec0000">&gt;</span> keys;
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint32_t</span><span style="color:#ec0000">&gt;</span> encry;
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint32_t</span><span style="color:#ec0000">&gt;</span> dummy;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> CDS<span style="color:#ec0000">-&gt;</span>getNumElements(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#5f5fff">uint32_t</span> K <span style="color:#ec0000">=</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t();
</span></span><span style="display:flex;"><span>          <span style="color:#5f5fff">uint64_t</span> V <span style="color:#ec0000">=</span> CDS<span style="color:#ec0000">-&gt;</span>getElementAsInteger(i);
</span></span><span style="display:flex;"><span>          keys.push_back(K);
</span></span><span style="display:flex;"><span>          encry.push_back(K <span style="color:#ec0000">^</span> V);
</span></span><span style="display:flex;"><span>          dummy.push_back(rand());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        KeyConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                          ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint32_t</span><span style="color:#ec0000">&gt;</span>(keys));
</span></span><span style="display:flex;"><span>        EncryptedConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                                ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint32_t</span><span style="color:#ec0000">&gt;</span>(encry));
</span></span><span style="display:flex;"><span>        DummyConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                                ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint32_t</span><span style="color:#ec0000">&gt;</span>(dummy));
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> <span style="color:#ec0000">if</span> (intType <span style="color:#ec0000">==</span> Type<span style="color:#ec0000">::</span>getInt64Ty(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext())) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint64_t</span><span style="color:#ec0000">&gt;</span> keys;
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint64_t</span><span style="color:#ec0000">&gt;</span> encry;
</span></span><span style="display:flex;"><span>        vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint64_t</span><span style="color:#ec0000">&gt;</span> dummy;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> CDS<span style="color:#ec0000">-&gt;</span>getNumElements(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#5f5fff">uint64_t</span> K <span style="color:#ec0000">=</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint64_t();
</span></span><span style="display:flex;"><span>          <span style="color:#5f5fff">uint64_t</span> V <span style="color:#ec0000">=</span> CDS<span style="color:#ec0000">-&gt;</span>getElementAsInteger(i);
</span></span><span style="display:flex;"><span>          keys.push_back(K);
</span></span><span style="display:flex;"><span>          encry.push_back(K <span style="color:#ec0000">^</span> V);
</span></span><span style="display:flex;"><span>          dummy.push_back(rand());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        KeyConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                          ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint64_t</span><span style="color:#ec0000">&gt;</span>(keys));
</span></span><span style="display:flex;"><span>        EncryptedConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                                ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint64_t</span><span style="color:#ec0000">&gt;</span>(encry));
</span></span><span style="display:flex;"><span>        DummyConst <span style="color:#ec0000">=</span> ConstantDataArray<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getContext(),
</span></span><span style="display:flex;"><span>                                                ArrayRef<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint64_t</span><span style="color:#ec0000">&gt;</span>(dummy));
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>        errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;Unsupported CDS Type</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>        abort();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      // Prepare new rawGV
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>EncryptedRawGV <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> GlobalVariable(
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">*</span>(GV<span style="color:#ec0000">-&gt;</span>getParent()), EncryptedConst<span style="color:#ec0000">-&gt;</span>getType(), <span style="color:#ec0000">false</span>,
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getLinkage(), EncryptedConst, <span style="color:#008900">&#34;EncryptedString&#34;</span>, <span style="color:#ec0000">nullptr</span>,
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getThreadLocalMode(), GV<span style="color:#ec0000">-&gt;</span>getType()<span style="color:#ec0000">-&gt;</span>getAddressSpace());
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>DecryptSpaceGV <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> GlobalVariable(
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">*</span>(GV<span style="color:#ec0000">-&gt;</span>getParent()), DummyConst<span style="color:#ec0000">-&gt;</span>getType(), <span style="color:#ec0000">false</span>,
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getLinkage(), DummyConst, <span style="color:#008900">&#34;DecryptSpace&#34;</span>, <span style="color:#ec0000">nullptr</span>,
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getThreadLocalMode(), GV<span style="color:#ec0000">-&gt;</span>getType()<span style="color:#ec0000">-&gt;</span>getAddressSpace());
</span></span><span style="display:flex;"><span>      old2new[GV] <span style="color:#ec0000">=</span> make_pair(EncryptedRawGV, DecryptSpaceGV);
</span></span><span style="display:flex;"><span>      GV2Keys[DecryptSpaceGV] <span style="color:#ec0000">=</span> make_pair(KeyConst, EncryptedRawGV);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    // Now prepare ObjC new GV
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (GlobalVariable <span style="color:#ec0000">*</span><span style="color:#ec0000">GV</span> : objCStrings) {
</span></span><span style="display:flex;"><span>      ConstantStruct <span style="color:#ec0000">*</span>CS <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ConstantStruct<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getInitializer());
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>oldrawString <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(CS<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">2</span>)<span style="color:#ec0000">-&gt;</span>stripPointerCasts());
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (old2new.find(oldrawString) <span style="color:#ec0000">==</span> old2new.end()) { // Filter out zero initializers
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>EncryptedOCGV <span style="color:#ec0000">=</span> ObjectivCString(GV, <span style="color:#008900">&#34;EncryptedStringObjC&#34;</span>, oldrawString, old2new[oldrawString].first, CS);
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>DecryptSpaceOCGV <span style="color:#ec0000">=</span> ObjectivCString(GV, <span style="color:#008900">&#34;DecryptSpaceObjC&#34;</span>, oldrawString, old2new[oldrawString].second, CS);
</span></span><span style="display:flex;"><span>      old2new[GV] <span style="color:#ec0000">=</span> make_pair(EncryptedOCGV, DecryptSpaceOCGV);
</span></span><span style="display:flex;"><span>    } // End prepare ObjC new GV
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span>(old2new.empty() <span style="color:#ec0000">||</span> GV2Keys.empty())
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span>;
</span></span><span style="display:flex;"><span>    // Replace Uses
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (User <span style="color:#ec0000">*</span><span style="color:#ec0000">U</span> : Users) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (map<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span>, pair<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span>, GlobalVariable <span style="color:#ec0000">*&gt;&gt;::</span>iterator iter <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>               old2new.begin();
</span></span><span style="display:flex;"><span>           iter <span style="color:#ec0000">!=</span> old2new.end(); <span style="color:#ec0000">++</span>iter) {
</span></span><span style="display:flex;"><span>        U<span style="color:#ec0000">-&gt;</span>replaceUsesOfWith(iter<span style="color:#ec0000">-&gt;</span>first, iter<span style="color:#ec0000">-&gt;</span>second.second);
</span></span><span style="display:flex;"><span>        iter<span style="color:#ec0000">-&gt;</span>first<span style="color:#ec0000">-&gt;</span>removeDeadConstantUsers();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } // End Replace Uses
</span></span><span style="display:flex;"><span>    // CleanUp Old ObjC GVs
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (GlobalVariable <span style="color:#ec0000">*</span><span style="color:#ec0000">GV</span> : objCStrings) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (GV<span style="color:#ec0000">-&gt;</span>getNumUses() <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>        GV<span style="color:#ec0000">-&gt;</span>dropAllReferences();
</span></span><span style="display:flex;"><span>        old2new.erase(GV);
</span></span><span style="display:flex;"><span>        GV<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    // CleanUp Old Raw GVs
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (map<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span>, pair<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span>, GlobalVariable <span style="color:#ec0000">*&gt;&gt;::</span>iterator iter <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>             old2new.begin();
</span></span><span style="display:flex;"><span>         iter <span style="color:#ec0000">!=</span> old2new.end(); <span style="color:#ec0000">++</span>iter) {
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>toDelete <span style="color:#ec0000">=</span> iter<span style="color:#ec0000">-&gt;</span>first;
</span></span><span style="display:flex;"><span>      toDelete<span style="color:#ec0000">-&gt;</span>removeDeadConstantUsers();
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (toDelete<span style="color:#ec0000">-&gt;</span>getNumUses() <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>        toDelete<span style="color:#ec0000">-&gt;</span>dropAllReferences();
</span></span><span style="display:flex;"><span>        toDelete<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    GlobalVariable <span style="color:#ec0000">*</span>StatusGV <span style="color:#ec0000">=</span> encstatus[Func];
</span></span><span style="display:flex;"><span>    /*
</span></span><span style="display:flex;"><span>      - Split Original EntryPoint BB into A and C.
</span></span><span style="display:flex;"><span>      - Create new BB as Decryption BB between A and C. Adjust the terminators
</span></span><span style="display:flex;"><span>      into: A (Alloca a new array containing all)
</span></span><span style="display:flex;"><span>              |
</span></span><span style="display:flex;"><span>              B(If not decrypted)
</span></span><span style="display:flex;"><span>              |
</span></span><span style="display:flex;"><span>              C
</span></span><span style="display:flex;"><span>    */
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>A <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;</span>(Func<span style="color:#ec0000">-&gt;</span>getEntryBlock());
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>C <span style="color:#ec0000">=</span> A<span style="color:#ec0000">-&gt;</span>splitBasicBlock(A<span style="color:#ec0000">-&gt;</span>getFirstNonPHIOrDbgOrLifetime());
</span></span><span style="display:flex;"><span>    C<span style="color:#ec0000">-&gt;</span>setName(<span style="color:#008900">&#34;PrecedingBlock&#34;</span>);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>B <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        BasicBlock<span style="color:#ec0000">::</span>Create(Func<span style="color:#ec0000">-&gt;</span>getContext(), <span style="color:#008900">&#34;StringDecryptionBB&#34;</span>, Func, C);
</span></span><span style="display:flex;"><span>    // Change A&#39;s terminator to jump to B
</span></span><span style="display:flex;"><span>    // We&#39;ll add new terminator to jump C later
</span></span><span style="display:flex;"><span>    BranchInst <span style="color:#ec0000">*</span>newBr <span style="color:#ec0000">=</span> BranchInst<span style="color:#ec0000">::</span>Create(B);
</span></span><span style="display:flex;"><span>    ReplaceInstWithInst(A<span style="color:#ec0000">-&gt;</span>getTerminator(), newBr);
</span></span><span style="display:flex;"><span>    IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(A<span style="color:#ec0000">-&gt;</span>getFirstNonPHIOrDbgOrLifetime());
</span></span><span style="display:flex;"><span>    // Insert DecryptionCode
</span></span><span style="display:flex;"><span>    HandleDecryptionBlock(B, C, GV2Keys);
</span></span><span style="display:flex;"><span>    // Add atomic load checking status in A
</span></span><span style="display:flex;"><span>    LoadInst <span style="color:#ec0000">*</span>LI <span style="color:#ec0000">=</span> IRB.CreateLoad(StatusGV, <span style="color:#008900">&#34;LoadEncryptionStatus&#34;</span>);
</span></span><span style="display:flex;"><span>    LI<span style="color:#ec0000">-&gt;</span>setAtomic(AtomicOrdering<span style="color:#ec0000">::</span>Acquire); // Will be released at the start of
</span></span><span style="display:flex;"><span>                                            // C
</span></span><span style="display:flex;"><span>    LI<span style="color:#ec0000">-&gt;</span>setAlignment(<span style="color:#008900">4</span>);
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>condition <span style="color:#ec0000">=</span> IRB.CreateICmpEQ(
</span></span><span style="display:flex;"><span>        LI, ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Func<span style="color:#ec0000">-&gt;</span>getContext()), <span style="color:#008900">0</span>));
</span></span><span style="display:flex;"><span>    A<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>    BranchInst<span style="color:#ec0000">::</span>Create(B, C, condition, A);
</span></span><span style="display:flex;"><span>    // Add StoreInst atomically in C start
</span></span><span style="display:flex;"><span>    // No matter control flow is coming from A or B, the GVs must be decrypted
</span></span><span style="display:flex;"><span>    IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRBC(C<span style="color:#ec0000">-&gt;</span>getFirstNonPHIOrDbgOrLifetime());
</span></span><span style="display:flex;"><span>    StoreInst <span style="color:#ec0000">*</span>SI <span style="color:#ec0000">=</span> IRBC.CreateStore(
</span></span><span style="display:flex;"><span>        ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Func<span style="color:#ec0000">-&gt;</span>getContext()), <span style="color:#008900">1</span>), StatusGV);
</span></span><span style="display:flex;"><span>    SI<span style="color:#ec0000">-&gt;</span>setAlignment(<span style="color:#008900">4</span>);
</span></span><span style="display:flex;"><span>    SI<span style="color:#ec0000">-&gt;</span>setAtomic(AtomicOrdering<span style="color:#ec0000">::</span>Release); // Release the lock acquired in LI
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  } // End of HandleFunction
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  GlobalVariable <span style="color:#ec0000">*</span><span style="color:#5f5fff">ObjectivCString</span>(GlobalVariable <span style="color:#ec0000">*</span>GV, string name, GlobalVariable <span style="color:#ec0000">*</span>oldrawString, GlobalVariable <span style="color:#ec0000">*</span>newString, ConstantStruct <span style="color:#ec0000">*</span>CS) {
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>zero <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(GV<span style="color:#ec0000">-&gt;</span>getContext()), <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>      vector<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*&gt;</span> vals;
</span></span><span style="display:flex;"><span>      vals.push_back(CS<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>));
</span></span><span style="display:flex;"><span>      vals.push_back(CS<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>));
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>GEPed <span style="color:#ec0000">=</span> ConstantExpr<span style="color:#ec0000">::</span>getInBoundsGetElementPtr(<span style="color:#ec0000">nullptr</span>, newString, {zero, zero});
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (GEPed<span style="color:#ec0000">-&gt;</span>getType() <span style="color:#ec0000">==</span> CS<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">2</span>)<span style="color:#ec0000">-&gt;</span>getType()) {
</span></span><span style="display:flex;"><span>        vals.push_back(GEPed);
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>        Constant <span style="color:#ec0000">*</span>BitCasted <span style="color:#ec0000">=</span> ConstantExpr<span style="color:#ec0000">::</span>getBitCast(newString, CS<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">2</span>)<span style="color:#ec0000">-&gt;</span>getType());
</span></span><span style="display:flex;"><span>        vals.push_back(BitCasted);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      vals.push_back(CS<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">3</span>));
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>newCS <span style="color:#ec0000">=</span> ConstantStruct<span style="color:#ec0000">::</span>get(CS<span style="color:#ec0000">-&gt;</span>getType(), ArrayRef<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*&gt;</span>(vals));
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">new</span> GlobalVariable(
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">*</span>(GV<span style="color:#ec0000">-&gt;</span>getParent()), newCS<span style="color:#ec0000">-&gt;</span>getType(), <span style="color:#ec0000">false</span>, GV<span style="color:#ec0000">-&gt;</span>getLinkage(), newCS,
</span></span><span style="display:flex;"><span>          name.c_str(), <span style="color:#ec0000">nullptr</span>, GV<span style="color:#ec0000">-&gt;</span>getThreadLocalMode(),
</span></span><span style="display:flex;"><span>          GV<span style="color:#ec0000">-&gt;</span>getType()<span style="color:#ec0000">-&gt;</span>getAddressSpace());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#5f5fff">void</span> <span style="color:#5f5fff">HandleDecryptionBlock</span>(BasicBlock <span style="color:#ec0000">*</span>B, BasicBlock <span style="color:#ec0000">*</span>C,
</span></span><span style="display:flex;"><span>                             map<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span>, pair<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*</span>, GlobalVariable <span style="color:#ec0000">*&gt;&gt;</span> <span style="color:#ec0000">&amp;</span>GV2Keys) {
</span></span><span style="display:flex;"><span>    IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(B);
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>zero <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(B<span style="color:#ec0000">-&gt;</span>getContext()), <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (map<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*</span>, pair<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*</span>, GlobalVariable <span style="color:#ec0000">*&gt;&gt;::</span>iterator iter <span style="color:#ec0000">=</span> GV2Keys.begin();
</span></span><span style="display:flex;"><span>         iter <span style="color:#ec0000">!=</span> GV2Keys.end(); <span style="color:#ec0000">++</span>iter) {
</span></span><span style="display:flex;"><span>      ConstantDataArray <span style="color:#ec0000">*</span>CastedCDA <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ConstantDataArray<span style="color:#ec0000">&gt;</span>(iter<span style="color:#ec0000">-&gt;</span>second.first);
</span></span><span style="display:flex;"><span>      // Prevent optimization of encrypted data
</span></span><span style="display:flex;"><span>      appendToCompilerUsed(<span style="color:#ec0000">*</span>iter<span style="color:#ec0000">-&gt;</span>second.second<span style="color:#ec0000">-&gt;</span>getParent(),
</span></span><span style="display:flex;"><span>                           {iter<span style="color:#ec0000">-&gt;</span>second.second});
</span></span><span style="display:flex;"><span>      // Element-By-Element XOR so the fucking verifier won&#39;t complain
</span></span><span style="display:flex;"><span>      // Also, this hides keys
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> CastedCDA<span style="color:#ec0000">-&gt;</span>getType()<span style="color:#ec0000">-&gt;</span>getNumElements(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>        Value <span style="color:#ec0000">*</span>offset <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(B<span style="color:#ec0000">-&gt;</span>getContext()), i);
</span></span><span style="display:flex;"><span>        Value <span style="color:#ec0000">*</span>EncryptedGEP <span style="color:#ec0000">=</span> IRB.CreateGEP(iter<span style="color:#ec0000">-&gt;</span>second.second, {zero, offset});
</span></span><span style="display:flex;"><span>        Value <span style="color:#ec0000">*</span>DecryptedGEP <span style="color:#ec0000">=</span> IRB.CreateGEP(iter<span style="color:#ec0000">-&gt;</span>first, {zero, offset});
</span></span><span style="display:flex;"><span>        LoadInst <span style="color:#ec0000">*</span>LI <span style="color:#ec0000">=</span> IRB.CreateLoad(EncryptedGEP, <span style="color:#008900">&#34;EncryptedChar&#34;</span>);
</span></span><span style="display:flex;"><span>        Value <span style="color:#ec0000">*</span>XORed <span style="color:#ec0000">=</span> IRB.CreateXor(LI, CastedCDA<span style="color:#ec0000">-&gt;</span>getElementAsConstant(i));
</span></span><span style="display:flex;"><span>        IRB.CreateStore(XORed, DecryptedGEP);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    IRB.CreateBr(C);
</span></span><span style="display:flex;"><span>  } // End of HandleDecryptionBlock
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@.str = private unnamed_addr constant [6 x i8] c&#34;hello\00&#34;, align 1

define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %call = call i32 @puts(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  ret i32 0
}
declare i32 @puts(i8*) #1
</code></pre><p>已混淆IR(<code>-mllvm -enable-strcry</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@0 = private global i32 0
@EncryptedString = private global [6 x i8] c&#34;*d\D2\15-A&#34;
@DecryptSpace = private global [6 x i8] c&#34;\A7\F1\D9*\82\C8&#34;
@llvm.compiler.used = appending global [1 x i8*] [i8* getelementptr inbounds ([6 x i8], [6 x i8]* @EncryptedString, i32 0, i32 0)], section &#34;llvm.metadata&#34;

define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %LoadEncryptionStatus = load atomic i32, i32* @0 acquire, align 4
  %0 = icmp eq i32 %LoadEncryptionStatus, 0
  br i1 %0, label %StringDecryptionBB, label %PrecedingBlock

StringDecryptionBB:                               ; preds = %entry
  %EncryptedChar = load i8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @EncryptedString, i32 0, i32 0)
  %1 = xor i8 %EncryptedChar, 66
  store i8 %1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @DecryptSpace, i32 0, i32 0)
  %EncryptedChar1 = load i8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @EncryptedString, i32 0, i32 1)
  %2 = xor i8 %EncryptedChar1, 1
  store i8 %2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @DecryptSpace, i32 0, i32 1)
  %EncryptedChar2 = load i8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @EncryptedString, i32 0, i32 2)
  %3 = xor i8 %EncryptedChar2, -66
  store i8 %3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @DecryptSpace, i32 0, i32 2)
  %EncryptedChar3 = load i8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @EncryptedString, i32 0, i32 3)
  %4 = xor i8 %EncryptedChar3, 121
  store i8 %4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @DecryptSpace, i32 0, i32 3)
  %EncryptedChar4 = load i8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @EncryptedString, i32 0, i32 4)
  %5 = xor i8 %EncryptedChar4, 66
  store i8 %5, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @DecryptSpace, i32 0, i32 4)
  %EncryptedChar5 = load i8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @EncryptedString, i32 0, i32 5)
  %6 = xor i8 %EncryptedChar5, 65
  store i8 %6, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @DecryptSpace, i32 0, i32 5)
  br label %PrecedingBlock

PrecedingBlock:                                   ; preds = %entry, %StringDecryptionBB
  store atomic i32 1, i32* @0 release, align 4
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %7 = getelementptr inbounds [6 x i8], [6 x i8]* @DecryptSpace, i32 0, i32 0
  %call = call i32 @puts(i8* %7)
  ret i32 0
}

declare i32 @puts(i8*) #1
</code></pre><pre class="mermaid">flowchart LR
A([entry]) --> B([StringDecryptionBB])
A([entry]) --> C([PrecedingBlock])
B([StringDecryptionBB]) --> C([PrecedingBlock])
C([PrecedingBlock]) --> ret([ret])
</pre>
<p>  Hikari是用异或方式将静态区字符串在编译期加密，并在函数入口处动态解密到预分配的静态区，支持C/OC字符串</p>
<ul>
<li>因为字符串属于模块范围可操作的元素而非函数, 因此需要注册为ModulePass, 入口点为runOnModule</li>
<li>入口点使用toObfuscate判断是否需要字符串加密, HandleFunction为加密处理函数</li>
<li>HandleFunction区分出哪些全局数据是字符串, 以及哪些字符串需要混淆</li>
<li>需要处理编译期优化, 防止静态区数据丢失, 或者混淆逻辑被还原, 混淆和优化其实是2个方向相反的过程</li>
</ul>
<p>加解密过程:</p>
<ul>
<li>编译期Hikari将字符串异或加密并存储为可执行模块的静态数据, 预分配解密后的存储区, 对同一字符串的多个引用, Hikari会创建多份加密副本防止冲突</li>
<li>编译期Hikari将异或解密逻辑StringDecryptionBB插入到函数入口点</li>
<li>运行时可执行模块解密静态数据到预分配存储区, 使用LoadEncryptionStatus变量记录是否已解密, 如果未解密则执行StringDecryptionBB否则执行PrecedingBlock</li>
</ul>
<p>优缺点:</p>
<ul>
<li>异或加密简单可靠，兼容性较强</li>
<li>异或加密算法较简单；执行一次函数即可在静态内存取获取解密的字符串</li>
</ul>
<h4 id="pluto-globalencryption模块分析">Pluto GlobalEncryption模块分析</h4>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PreservedAnalyses GlobalEncryption<span style="color:#ec0000">::</span>run(Module <span style="color:#ec0000">&amp;</span>M, ModuleAnalysisManager <span style="color:#ec0000">&amp;</span>AM) {
</span></span><span style="display:flex;"><span>    std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span>GlobalVariable <span style="color:#ec0000">*&gt;</span> GVs;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">GV</span> : M.getGlobalList()) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>shouldSkip(GV)) {
</span></span><span style="display:flex;"><span>            GVs.push_back(<span style="color:#ec0000">&amp;</span>GV);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">GV</span> : GVs) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (ConstantDataArray <span style="color:#ec0000">*</span>dataArray <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantDataArray<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getInitializer())) {
</span></span><span style="display:flex;"><span>            <span style="color:#5f5fff">uint64_t</span> eleByteSize <span style="color:#ec0000">=</span> dataArray<span style="color:#ec0000">-&gt;</span>getElementByteSize();
</span></span><span style="display:flex;"><span>            <span style="color:#5f5fff">uint64_t</span> eleNum <span style="color:#ec0000">=</span> dataArray<span style="color:#ec0000">-&gt;</span>getNumElements();
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">*</span>data <span style="color:#ec0000">=</span> dataArray<span style="color:#ec0000">-&gt;</span>getRawDataValues().data();
</span></span><span style="display:flex;"><span>            <span style="color:#5f5fff">uint64_t</span> dataSize <span style="color:#ec0000">=</span> eleByteSize <span style="color:#ec0000">*</span> eleNum;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (data <span style="color:#ec0000">&amp;&amp;</span> eleByteSize <span style="color:#ec0000">&lt;=</span> <span style="color:#008900">8</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#5f5fff">char</span> <span style="color:#ec0000">*</span>dataCopy <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> <span style="color:#5f5fff">char</span>[dataSize];
</span></span><span style="display:flex;"><span>                memcpy(dataCopy, data, dataSize);
</span></span><span style="display:flex;"><span>                <span style="color:#5f5fff">uint64_t</span> key <span style="color:#ec0000">=</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint64_t();
</span></span><span style="display:flex;"><span>                // A simple xor encryption
</span></span><span style="display:flex;"><span>                <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">uint32_t</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> dataSize; i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>                    dataCopy[i] <span style="color:#ec0000">^=</span> ((<span style="color:#5f5fff">char</span> <span style="color:#ec0000">*</span>)<span style="color:#ec0000">&amp;</span>key)[i <span style="color:#ec0000">%</span> eleByteSize];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                GV<span style="color:#ec0000">-&gt;</span>setInitializer(
</span></span><span style="display:flex;"><span>                    ConstantDataArray<span style="color:#ec0000">::</span>getRaw(StringRef(dataCopy, dataSize), eleNum, dataArray<span style="color:#ec0000">-&gt;</span>getElementType()));
</span></span><span style="display:flex;"><span>                GV<span style="color:#ec0000">-&gt;</span>setConstant(<span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>                insertArrayDecryption(M, GV, key, eleNum);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#ec0000">else</span> <span style="color:#5f5fff">if</span> (ConstantInt <span style="color:#ec0000">*</span>dataInt <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getInitializer())) {
</span></span><span style="display:flex;"><span>            <span style="color:#5f5fff">uint64_t</span> key <span style="color:#ec0000">=</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint64_t();
</span></span><span style="display:flex;"><span>            ConstantInt <span style="color:#ec0000">*</span>enc <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(dataInt<span style="color:#ec0000">-&gt;</span>getType(), key <span style="color:#ec0000">^</span> dataInt<span style="color:#ec0000">-&gt;</span>getZExtValue());
</span></span><span style="display:flex;"><span>            GV<span style="color:#ec0000">-&gt;</span>setInitializer(enc);
</span></span><span style="display:flex;"><span>            GV<span style="color:#ec0000">-&gt;</span>setConstant(<span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>            insertIntDecryption(M, GV, key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> PreservedAnalyses<span style="color:#ec0000">::</span>all();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> GlobalEncryption<span style="color:#ec0000">::</span>insertArrayDecryption(Module <span style="color:#ec0000">&amp;</span>M, GlobalVariable <span style="color:#ec0000">*</span>GV, <span style="color:#5f5fff">uint64_t</span> key, <span style="color:#5f5fff">uint64_t</span> eleNum) {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">static</span> <span style="color:#5f5fff">uint64_t</span> cnt <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>    LLVMContext <span style="color:#ec0000">&amp;</span>context <span style="color:#ec0000">=</span> M.getContext();
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>funcType <span style="color:#ec0000">=</span> FunctionType<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getVoidTy(context), <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#ec0000">::</span>string funcName <span style="color:#ec0000">=</span> formatv(<span style="color:#008900">&#34;decrypt.arr.{0:d}&#34;</span>, cnt<span style="color:#ec0000">++</span>);
</span></span><span style="display:flex;"><span>    FunctionCallee callee <span style="color:#ec0000">=</span> M.getOrInsertFunction(funcName, funcType);
</span></span><span style="display:flex;"><span>    Function <span style="color:#ec0000">*</span>func <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(callee.getCallee());
</span></span><span style="display:flex;"><span>    func<span style="color:#ec0000">-&gt;</span>setLinkage(GlobalValue<span style="color:#ec0000">::</span>LinkageTypes<span style="color:#ec0000">::</span>PrivateLinkage);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>head <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;head&#34;</span>, func);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>forCond <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;for.cond&#34;</span>, func);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>forBody <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;for.body&#34;</span>, func);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>forInc <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;for.inc&#34;</span>, func);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>forEnd <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;for.inc&#34;</span>, func);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IRBuilder<span style="color:#ec0000">&lt;&gt;</span> builder(context);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(head);
</span></span><span style="display:flex;"><span>    AllocaInst <span style="color:#ec0000">*</span>indexPtr <span style="color:#ec0000">=</span> builder.CreateAlloca(Type<span style="color:#ec0000">::</span>getInt32Ty(context));
</span></span><span style="display:flex;"><span>    builder.CreateStore(ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(context), <span style="color:#008900">0</span>), indexPtr);
</span></span><span style="display:flex;"><span>    builder.CreateBr(forCond);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(forCond);
</span></span><span style="display:flex;"><span>    LoadInst <span style="color:#ec0000">*</span>index <span style="color:#ec0000">=</span> builder.CreateLoad(Type<span style="color:#ec0000">::</span>getInt32Ty(context), indexPtr);
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>cond <span style="color:#ec0000">=</span> builder.CreateICmpSLT(index, ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(context), eleNum));
</span></span><span style="display:flex;"><span>    builder.CreateCondBr(cond, forBody, forEnd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(forBody);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>elePtr <span style="color:#ec0000">=</span> builder.CreateGEP(GV<span style="color:#ec0000">-&gt;</span>getValueType(), GV, {ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(context), <span style="color:#008900">0</span>), index});
</span></span><span style="display:flex;"><span>    Type <span style="color:#ec0000">*</span>eleType <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ArrayType<span style="color:#ec0000">&gt;</span>(GV<span style="color:#ec0000">-&gt;</span>getValueType())<span style="color:#ec0000">-&gt;</span>getElementType();
</span></span><span style="display:flex;"><span>    builder.CreateStore(builder.CreateXor(builder.CreateLoad(eleType, elePtr), ConstantInt<span style="color:#ec0000">::</span>get(eleType, key)), elePtr);
</span></span><span style="display:flex;"><span>    builder.CreateBr(forInc);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(forInc);
</span></span><span style="display:flex;"><span>    builder.CreateStore(builder.CreateAdd(index, ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(context), <span style="color:#008900">1</span>)), indexPtr);
</span></span><span style="display:flex;"><span>    builder.CreateBr(forCond);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(forEnd);
</span></span><span style="display:flex;"><span>    builder.CreateRetVoid();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    appendToGlobalCtors(M, func, <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> GlobalEncryption<span style="color:#ec0000">::</span>insertIntDecryption(Module <span style="color:#ec0000">&amp;</span>M, GlobalVariable <span style="color:#ec0000">*</span>GV, <span style="color:#5f5fff">uint64_t</span> key) {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">static</span> <span style="color:#5f5fff">uint64_t</span> cnt <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>    LLVMContext <span style="color:#ec0000">&amp;</span>context <span style="color:#ec0000">=</span> M.getContext();
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>funcType <span style="color:#ec0000">=</span> FunctionType<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getVoidTy(context), <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#ec0000">::</span>string funcName <span style="color:#ec0000">=</span> formatv(<span style="color:#008900">&#34;decrypt.int.{0:d}&#34;</span>, cnt<span style="color:#ec0000">++</span>);
</span></span><span style="display:flex;"><span>    FunctionCallee callee <span style="color:#ec0000">=</span> M.getOrInsertFunction(funcName, funcType);
</span></span><span style="display:flex;"><span>    Function <span style="color:#ec0000">*</span>func <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(callee.getCallee());
</span></span><span style="display:flex;"><span>    func<span style="color:#ec0000">-&gt;</span>setLinkage(GlobalValue<span style="color:#ec0000">::</span>LinkageTypes<span style="color:#ec0000">::</span>PrivateLinkage);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>BB <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;BB&#34;</span>, func);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IRBuilder<span style="color:#ec0000">&lt;&gt;</span> builder(context);
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(BB);
</span></span><span style="display:flex;"><span>    LoadInst <span style="color:#ec0000">*</span>val <span style="color:#ec0000">=</span> builder.CreateLoad(GV<span style="color:#ec0000">-&gt;</span>getValueType(), GV);
</span></span><span style="display:flex;"><span>    builder.CreateStore(builder.CreateXor(val, ConstantInt<span style="color:#ec0000">::</span>get(GV<span style="color:#ec0000">-&gt;</span>getValueType(), key)), GV);
</span></span><span style="display:flex;"><span>    builder.CreateRetVoid();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    appendToGlobalCtors(M, func, <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@.str = private unnamed_addr constant [6 x i8] c&#34;hello\00&#34;, align 1

define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %call = call i32 @puts(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  ret i32 0
}
declare i32 @puts(i8*) #1
</code></pre><p>已混淆IR(<code>-mllvm -passes=gle</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@.str = private unnamed_addr global [6 x i8] c&#34;\11\1C\15\15\16y&#34;, align 1
@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @decrypt.arr.0, i8* null }]

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @main(i32 noundef %argc, i8** noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %call = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))
  ret i32 0
}

declare i32 @printf(i8* noundef, ...) #1

define private void @decrypt.arr.0() {
head:
  %0 = alloca i32, align 4
  store i32 0, i32* %0, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %head
  %1 = load i32, i32* %0, align 4
  %2 = icmp slt i32 %1, 6
  br i1 %2, label %for.body, label %for.inc1

for.body:                                         ; preds = %for.cond
  %3 = getelementptr [6 x i8], [6 x i8]* @.str, i32 0, i32 %1
  %4 = load i8, i8* %3, align 1
  %5 = xor i8 %4, 121
  store i8 %5, i8* %3, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = add i32 %1, 1
  store i32 %6, i32* %0, align 4
  br label %for.cond

for.inc1:                                         ; preds = %for.cond
  ret void
}
</code></pre><p>总结:</p>
<ul>
<li>Pluto和Hikari不同在于, 解密逻辑放到ctors段执行而不是每个函数中</li>
</ul>
<h3 id="goron-indirectglobalvariable模块分析">goron IndirectGlobalVariable模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">runOnFunction</span>(Function <span style="color:#ec0000">&amp;</span>Fn) <span style="color:#ec0000">override</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>toObfuscate(flag, <span style="color:#ec0000">&amp;</span>Fn, <span style="color:#008900">&#34;indgv&#34;</span>)) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (Options <span style="color:#ec0000">&amp;&amp;</span> Options<span style="color:#ec0000">-&gt;</span>skipFunction(Fn.getName())) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LLVMContext <span style="color:#ec0000">&amp;</span>Ctx <span style="color:#ec0000">=</span> Fn.getContext();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    GVNumbering.clear();
</span></span><span style="display:flex;"><span>    GlobalVariables.clear();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LowerConstantExpr(Fn);
</span></span><span style="display:flex;"><span>    NumberGlobalVariable(Fn);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (GlobalVariables.empty()) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">uint32_t</span> V <span style="color:#ec0000">=</span> RandomEngine.get_uint32_t() <span style="color:#ec0000">&amp;</span> <span style="color:#ec0000">~</span><span style="color:#008900">3</span>;
</span></span><span style="display:flex;"><span>    ConstantInt <span style="color:#ec0000">*</span>EncKey <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), V, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">const</span> IPObfuscationContext<span style="color:#ec0000">::</span>IPOInfo <span style="color:#ec0000">*</span>SecretInfo <span style="color:#ec0000">=</span> <span style="color:#ec0000">nullptr</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (IPO) {
</span></span><span style="display:flex;"><span>      SecretInfo <span style="color:#ec0000">=</span> IPO<span style="color:#ec0000">-&gt;</span>getIPOInfo(<span style="color:#ec0000">&amp;</span>Fn);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>MySecret;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (SecretInfo) {
</span></span><span style="display:flex;"><span>      MySecret <span style="color:#ec0000">=</span> SecretInfo<span style="color:#ec0000">-&gt;</span>SecretLI;
</span></span><span style="display:flex;"><span>    } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>      MySecret <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), <span style="color:#008900">0</span>, <span style="color:#ec0000">true</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ConstantInt <span style="color:#ec0000">*</span>Zero <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>    GlobalVariable <span style="color:#ec0000">*</span>GVars <span style="color:#ec0000">=</span> getIndirectGlobalVariables(Fn, EncKey);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (inst_iterator I <span style="color:#ec0000">=</span> inst_begin(Fn), E <span style="color:#ec0000">=</span> inst_end(Fn); I <span style="color:#ec0000">!=</span> E; <span style="color:#ec0000">++</span>I) {
</span></span><span style="display:flex;"><span>      Instruction <span style="color:#ec0000">*</span>Inst <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;*</span>I;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (PHINode <span style="color:#ec0000">*</span>PHI <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>PHINode<span style="color:#ec0000">&gt;</span>(Inst)) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> <span style="color:#5f5fff">int</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> PHI<span style="color:#ec0000">-&gt;</span>getNumIncomingValues(); <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>          Value <span style="color:#ec0000">*</span>val <span style="color:#ec0000">=</span> PHI<span style="color:#ec0000">-&gt;</span>getIncomingValue(i);
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (GlobalVariable <span style="color:#ec0000">*</span>GV <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(val)) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (GVNumbering.count(GV) <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Instruction <span style="color:#ec0000">*</span>IP <span style="color:#ec0000">=</span> PHI<span style="color:#ec0000">-&gt;</span>getIncomingBlock(i)<span style="color:#ec0000">-&gt;</span>getTerminator();
</span></span><span style="display:flex;"><span>            IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(IP);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>Idx <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), GVNumbering[GV]);
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>GEP <span style="color:#ec0000">=</span> IRB.CreateGEP(GVars, {Zero, Idx});
</span></span><span style="display:flex;"><span>            LoadInst <span style="color:#ec0000">*</span>EncGVAddr <span style="color:#ec0000">=</span> IRB.CreateLoad(GEP, GV<span style="color:#ec0000">-&gt;</span>getName());
</span></span><span style="display:flex;"><span>            Constant <span style="color:#ec0000">*</span>X;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (SecretInfo) {
</span></span><span style="display:flex;"><span>              X <span style="color:#ec0000">=</span> ConstantExpr<span style="color:#ec0000">::</span>getSub(SecretInfo<span style="color:#ec0000">-&gt;</span>SecretCI, EncKey);
</span></span><span style="display:flex;"><span>            } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>              X <span style="color:#ec0000">=</span> ConstantExpr<span style="color:#ec0000">::</span>getSub(Zero, EncKey);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>Secret <span style="color:#ec0000">=</span> IRB.CreateSub(X, MySecret);
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>GVAddr <span style="color:#ec0000">=</span> IRB.CreateGEP(EncGVAddr, Secret);
</span></span><span style="display:flex;"><span>            GVAddr <span style="color:#ec0000">=</span> IRB.CreateBitCast(GVAddr, GV<span style="color:#ec0000">-&gt;</span>getType());
</span></span><span style="display:flex;"><span>            GVAddr<span style="color:#ec0000">-&gt;</span>setName(<span style="color:#008900">&#34;IndGV&#34;</span>);
</span></span><span style="display:flex;"><span>            Inst<span style="color:#ec0000">-&gt;</span>replaceUsesOfWith(GV, GVAddr);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (User<span style="color:#ec0000">::</span>op_iterator op <span style="color:#ec0000">=</span> Inst<span style="color:#ec0000">-&gt;</span>op_begin(); op <span style="color:#ec0000">!=</span> Inst<span style="color:#ec0000">-&gt;</span>op_end(); <span style="color:#ec0000">++</span>op) {
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (GlobalVariable <span style="color:#ec0000">*</span>GV <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(<span style="color:#ec0000">*</span>op)) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (GVNumbering.count(GV) <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(Inst);
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>Idx <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), GVNumbering[GV]);
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>GEP <span style="color:#ec0000">=</span> IRB.CreateGEP(GVars, {Zero, Idx});
</span></span><span style="display:flex;"><span>            LoadInst <span style="color:#ec0000">*</span>EncGVAddr <span style="color:#ec0000">=</span> IRB.CreateLoad(GEP, GV<span style="color:#ec0000">-&gt;</span>getName());
</span></span><span style="display:flex;"><span>            Constant <span style="color:#ec0000">*</span>X;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (SecretInfo) {
</span></span><span style="display:flex;"><span>              X <span style="color:#ec0000">=</span> ConstantExpr<span style="color:#ec0000">::</span>getSub(SecretInfo<span style="color:#ec0000">-&gt;</span>SecretCI, EncKey);
</span></span><span style="display:flex;"><span>            } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>              X <span style="color:#ec0000">=</span> ConstantExpr<span style="color:#ec0000">::</span>getSub(Zero, EncKey);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>Secret <span style="color:#ec0000">=</span> IRB.CreateSub(X, MySecret);
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>GVAddr <span style="color:#ec0000">=</span> IRB.CreateGEP(EncGVAddr, Secret);
</span></span><span style="display:flex;"><span>            GVAddr <span style="color:#ec0000">=</span> IRB.CreateBitCast(GVAddr, GV<span style="color:#ec0000">-&gt;</span>getType());
</span></span><span style="display:flex;"><span>            GVAddr<span style="color:#ec0000">-&gt;</span>setName(<span style="color:#008900">&#34;IndGV&#34;</span>);
</span></span><span style="display:flex;"><span>            Inst<span style="color:#ec0000">-&gt;</span>replaceUsesOfWith(GV, GVAddr);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@.str = private unnamed_addr constant [6 x i8] c&#34;hello\00&#34;, align 1

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}
</code></pre><p>已混淆IR(<code>-mllvm -irobf-indgv</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@.str = private unnamed_addr constant [6 x i8] c&#34;hello\00&#34;, align 1
@main_IndirectGVars = private global [1 x i8*] [i8* getelementptr (i8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i32 731375704)]
@llvm.compiler.used = appending global [1 x i8*] [i8* bitcast ([1 x i8*]* @main_IndirectGVars to i8*)], section &#34;llvm.metadata&#34;

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %CallerSlot = alloca i32, align 4
  %CalleeSlot = alloca i32, align 4
  store i32 1941440102, i32* %CallerSlot
  %MySecret = load i32, i32* %CallerSlot
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %.str = load i8*, i8** getelementptr inbounds ([1 x i8*], [1 x i8*]* @main_IndirectGVars, i32 0, i32 0)
  %1 = sub i32 1210064398, %MySecret
  %2 = getelementptr i8, i8* %.str, i32 %1
  %IndGV = bitcast i8* %2 to [6 x i8]*
  %3 = getelementptr inbounds [6 x i8], [6 x i8]* %IndGV, i64 0, i64 0
  %call = call i32 (i8*, ...) @printf(i8* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}
</code></pre><h3 id="实验将静态字符串转换为栈字符串">实验:将静态字符串转换为栈字符串</h3>
<p>  以下代码在LLVM8-18下测试, 仅使用NewPass. 注意本节只是为了验证静态转栈的可行性, 不推荐实际使用.</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>#include &#34;llvm/IR/IRBuilder.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/IR/LegacyPassManager.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Pass.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Passes/PassBuilder.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Passes/PassPlugin.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;llvm/Support/raw_ostream.h&#34;
</span></span><span style="display:flex;"><span>#if LLVM_VERSION_MAJOR &lt;= 15
</span></span><span style="display:flex;"><span>#include &#34;llvm/Transforms/IPO/PassManagerBuilder.h&#34;
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">using</span> <span style="color:#ec0000">namespace</span> llvm;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#define PASSNAME          &#34;MyPassDemo&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">static</span> <span style="color:#5f5fff">void</span> <span style="color:#5f5fff">doModule</span>(Module<span style="color:#ec0000">&amp;</span> M);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// ---------------- New Pass ---------------- //
</span></span><span style="display:flex;"><span>#if LLVM_VERSION_MAJOR &lt;= 13
</span></span><span style="display:flex;"><span>#define OptimizationLevel PassBuilder::OptimizationLevel
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">class</span> <span style="color:#5f5fff">MyPassDemo</span> <span style="color:#ec0000">:</span> <span style="color:#ec0000">public</span> PassInfoMixin<span style="color:#ec0000">&lt;</span>MyPassDemo<span style="color:#ec0000">&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#ec0000">public</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>    PreservedAnalyses run(Module <span style="color:#ec0000">&amp;</span>M, ModuleAnalysisManager <span style="color:#ec0000">&amp;</span>AM) {
</span></span><span style="display:flex;"><span>        doModule(M);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">return</span> PreservedAnalyses<span style="color:#ec0000">::</span>all();
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">static</span> <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">isRequired</span>() { <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">extern</span> <span style="color:#008900">&#34;C&#34;</span> LLVM_ATTRIBUTE_WEAK <span style="color:#ec0000">::</span>llvm<span style="color:#ec0000">::</span>PassPluginLibraryInfo llvmGetPassPluginInfo() {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> {
</span></span><span style="display:flex;"><span>        .APIVersion <span style="color:#ec0000">=</span> LLVM_PLUGIN_API_VERSION,
</span></span><span style="display:flex;"><span>        .PluginName <span style="color:#ec0000">=</span> PASSNAME,
</span></span><span style="display:flex;"><span>        .PluginVersion <span style="color:#ec0000">=</span> <span style="color:#008900">&#34;1.0&#34;</span>,
</span></span><span style="display:flex;"><span>        .RegisterPassBuilderCallbacks <span style="color:#ec0000">=</span> [](PassBuilder <span style="color:#ec0000">&amp;</span>PB) {
</span></span><span style="display:flex;"><span>            PB.registerPipelineStartEPCallback(
</span></span><span style="display:flex;"><span>                [](ModulePassManager <span style="color:#ec0000">&amp;</span>MPM
</span></span><span style="display:flex;"><span>#if LLVM_VERSION_MAJOR &gt;= 12
</span></span><span style="display:flex;"><span>                , OptimizationLevel Level
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span>                ) {
</span></span><span style="display:flex;"><span>                    MPM.addPass(MyPassDemo());
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>            PB.registerPipelineParsingCallback(
</span></span><span style="display:flex;"><span>                [](StringRef Name, ModulePassManager<span style="color:#ec0000">&amp;</span> MPM, ArrayRef<span style="color:#ec0000">&lt;</span>PassBuilder<span style="color:#ec0000">::</span>PipelineElement<span style="color:#ec0000">&gt;</span>) {
</span></span><span style="display:flex;"><span>                    MPM.addPass(MyPassDemo());
</span></span><span style="display:flex;"><span>                    <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>// ---------------- New Pass ---------------- //
</span></span><span style="display:flex;"><span>#include &lt;vector&gt;
</span></span><span style="display:flex;"><span><span style="color:#ec0000">class</span> <span style="color:#5f5fff">TodoItem</span> {
</span></span><span style="display:flex;"><span><span style="color:#ec0000">public</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>    Instruction<span style="color:#ec0000">*</span>    inst;
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">unsigned</span>        idx;
</span></span><span style="display:flex;"><span>    StringRef       data;     
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> <span style="color:#5f5fff">doModule</span>(Module<span style="color:#ec0000">&amp;</span> M) {   
</span></span><span style="display:flex;"><span>    std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span>TodoItem<span style="color:#ec0000">&gt;</span> todo_list;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">auto</span> handle_gv <span style="color:#ec0000">=</span> [<span style="color:#ec0000">&amp;</span>todo_list](Instruction<span style="color:#ec0000">*</span> I, <span style="color:#5f5fff">unsigned</span> i, GlobalVariable<span style="color:#ec0000">*</span> GV) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (GV<span style="color:#ec0000">-&gt;</span>isConstant() <span style="color:#ec0000">&amp;&amp;</span> GV<span style="color:#ec0000">-&gt;</span>hasInitializer()) {
</span></span><span style="display:flex;"><span>            Constant<span style="color:#ec0000">*</span> GVI <span style="color:#ec0000">=</span> GV<span style="color:#ec0000">-&gt;</span>getInitializer();
</span></span><span style="display:flex;"><span>            ConstantDataArray<span style="color:#ec0000">*</span> CDA <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantDataArray<span style="color:#ec0000">&gt;</span>(GVI);
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (CDA <span style="color:#ec0000">!=</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>                StringRef data <span style="color:#ec0000">=</span> CDA<span style="color:#ec0000">-&gt;</span>getAsString(); // 如果是字符串则包括&#39;\0&#39;
</span></span><span style="display:flex;"><span>                <span style="color:#ec0000">if</span> (data.size() <span style="color:#ec0000">&gt;=</span> <span style="color:#008900">2</span>) {
</span></span><span style="display:flex;"><span>                    errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;Add todo_list: &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> data <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>                    todo_list.push_back({I, i, data});
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (Function<span style="color:#ec0000">&amp;</span> <span style="color:#ec0000">F</span> : M) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (BasicBlock<span style="color:#ec0000">&amp;</span> <span style="color:#ec0000">bb</span> : F) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">for</span> (Instruction<span style="color:#ec0000">&amp;</span> <span style="color:#ec0000">I</span> : bb) {
</span></span><span style="display:flex;"><span>                <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> I.getNumOperands(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>                    Value<span style="color:#ec0000">*</span> v <span style="color:#ec0000">=</span> I.getOperand(i);
</span></span><span style="display:flex;"><span>                    <span style="color:#5f5fff">unsigned</span> valueID <span style="color:#ec0000">=</span> v<span style="color:#ec0000">-&gt;</span>getValueID();
</span></span><span style="display:flex;"><span>                    <span style="color:#ec0000">if</span> (valueID <span style="color:#ec0000">==</span> Value<span style="color:#ec0000">::</span>GlobalVariableVal) { // LLVM&gt;=15
</span></span><span style="display:flex;"><span>                        GlobalVariable<span style="color:#ec0000">*</span> GV <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(v);
</span></span><span style="display:flex;"><span>                        handle_gv(<span style="color:#ec0000">&amp;</span>I, i, GV);
</span></span><span style="display:flex;"><span>                        // @printf(ptr noundef @.str) -&gt; @printf(ptr noundef %str)
</span></span><span style="display:flex;"><span>                    } <span style="color:#ec0000">else</span> <span style="color:#ec0000">if</span> (valueID <span style="color:#ec0000">==</span> Value<span style="color:#ec0000">::</span>ConstantExprVal) { // LLVM&lt;=14
</span></span><span style="display:flex;"><span>                        ConstantExpr<span style="color:#ec0000">*</span> CE <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantExpr<span style="color:#ec0000">&gt;</span>(v);
</span></span><span style="display:flex;"><span>                        <span style="color:#5f5fff">unsigned</span> op <span style="color:#ec0000">=</span> CE<span style="color:#ec0000">-&gt;</span>getOpcode();
</span></span><span style="display:flex;"><span>                        <span style="color:#ec0000">if</span> (op <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>GetElementPtr) {
</span></span><span style="display:flex;"><span>                            Value<span style="color:#ec0000">*</span> v0 <span style="color:#ec0000">=</span> CE<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>                            Value<span style="color:#ec0000">*</span> v1 <span style="color:#ec0000">=</span> CE<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>);
</span></span><span style="display:flex;"><span>                            Value<span style="color:#ec0000">*</span> v2 <span style="color:#ec0000">=</span> CE<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">2</span>);
</span></span><span style="display:flex;"><span>                            <span style="color:#5f5fff">unsigned</span> vID0 <span style="color:#ec0000">=</span> v0<span style="color:#ec0000">-&gt;</span>getValueID();
</span></span><span style="display:flex;"><span>                            <span style="color:#5f5fff">unsigned</span> vID1 <span style="color:#ec0000">=</span> v1<span style="color:#ec0000">-&gt;</span>getValueID();
</span></span><span style="display:flex;"><span>                            <span style="color:#5f5fff">unsigned</span> vID2 <span style="color:#ec0000">=</span> v2<span style="color:#ec0000">-&gt;</span>getValueID();
</span></span><span style="display:flex;"><span>                            <span style="color:#ec0000">if</span> (vID0 <span style="color:#ec0000">==</span> Value<span style="color:#ec0000">::</span>GlobalVariableVal <span style="color:#ec0000">&amp;&amp;</span> vID1 <span style="color:#ec0000">==</span> Value<span style="color:#ec0000">::</span>ConstantIntVal <span style="color:#ec0000">&amp;&amp;</span> vID2 <span style="color:#ec0000">==</span> Value<span style="color:#ec0000">::</span>ConstantIntVal ) {
</span></span><span style="display:flex;"><span>                                <span style="color:#ec0000">if</span> (dyn_cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(v1)<span style="color:#ec0000">-&gt;</span>getSExtValue() <span style="color:#ec0000">==</span> <span style="color:#008900">0</span> <span style="color:#ec0000">&amp;&amp;</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(v2)<span style="color:#ec0000">-&gt;</span>getSExtValue() <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>                                    GlobalVariable<span style="color:#ec0000">*</span> GV <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(v0);
</span></span><span style="display:flex;"><span>                                    handle_gv(<span style="color:#ec0000">&amp;</span>I, <span style="color:#008900">0</span>, GV);
</span></span><span style="display:flex;"><span>                                    // @printf(i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i64 0, i64 0)) -&gt; @printf(i8* noundef %str)
</span></span><span style="display:flex;"><span>                                }
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (TodoItem<span style="color:#ec0000">&amp;</span> <span style="color:#ec0000">item</span> : todo_list) {
</span></span><span style="display:flex;"><span>        Instruction<span style="color:#ec0000">*</span> inst <span style="color:#ec0000">=</span> item.inst;
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">unsigned</span> idx <span style="color:#ec0000">=</span> item.idx;
</span></span><span style="display:flex;"><span>        StringRef data <span style="color:#ec0000">=</span> item.data;     
</span></span><span style="display:flex;"><span>        BasicBlock<span style="color:#ec0000">*</span> bb <span style="color:#ec0000">=</span> inst<span style="color:#ec0000">-&gt;</span>getParent();
</span></span><span style="display:flex;"><span>        IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(<span style="color:#ec0000">&amp;</span>bb<span style="color:#ec0000">-&gt;</span>front());
</span></span><span style="display:flex;"><span>        AllocaInst<span style="color:#ec0000">*</span> alloca <span style="color:#ec0000">=</span> IRB.CreateAlloca(IRB.getInt8Ty(), IRB.getInt32(data.size()));
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> data.size(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>            Value<span style="color:#ec0000">*</span> gep <span style="color:#ec0000">=</span> IRB.CreateConstGEP1_64(IRB.getInt8Ty(), alloca, i);
</span></span><span style="display:flex;"><span>            Constant<span style="color:#ec0000">*</span> n <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(IRB.getInt8Ty(), data[i]);
</span></span><span style="display:flex;"><span>            IRB.CreateStore(n, gep);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        inst<span style="color:#ec0000">-&gt;</span>setOperand(idx, alloca);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p> <br>
测试<br>
 </p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// /tmp/1.cpp
</span></span><span style="display:flex;"><span>#include &lt;stdio.h&gt;
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#5f5fff">char</span><span style="color:#ec0000">**</span> argv) {
</span></span><span style="display:flex;"><span>	printf(<span style="color:#008900">&#34;helloworld&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ec0000">return</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译为Debug</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>llvm15/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk iphoneos --show-sdk-path<span style="color:#008900">`</span> -arch arm64 -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo15.dylib -o /tmp/1.bin /tmp/1.cpp 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">E8C</span>                 <span style="color:#008900">SUB</span>             <span style="color:#008900">X0</span>, <span style="color:#008900">X29</span>, #-var_13 ; char *
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">E90</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W9</span>, #0x68
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">E94</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W9</span>, [<span style="color:#008900">X29</span>,#var_13]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">E98</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W9</span>, #0x65
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">E9C</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W9</span>, [<span style="color:#008900">X29</span>,#var_12]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EA0</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W9</span>, #0x6C
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EA4</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W9</span>, [<span style="color:#008900">X29</span>,#var_11]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EA8</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W9</span>, [<span style="color:#008900">X29</span>,#var_10]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EAC</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W10</span>, #0x6F
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EB0</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W10</span>, [<span style="color:#008900">X29</span>,#var_F]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EB4</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W11</span>, #0x77
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EB8</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W11</span>, [<span style="color:#008900">X29</span>,#var_E]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EBC</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W10</span>, [<span style="color:#008900">X29</span>,#var_D]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EC0</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W10</span>, #0x72
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EC4</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W10</span>, [<span style="color:#008900">X29</span>,#var_C]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EC8</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W9</span>, [<span style="color:#008900">X29</span>,#var_B]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">ECC</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W9</span>, #0x64
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">ED0</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">W9</span>, [<span style="color:#008900">X29</span>,#var_A]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">ED4</span>                 <span style="color:#008900">STURB</span>           <span style="color:#008900">WZR</span>, [<span style="color:#008900">X29</span>,#var_9]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">ED8</span>                 <span style="color:#008900">STR</span>             <span style="color:#008900">WZR</span>, [<span style="color:#008900">SP</span>,#0x30+var_18]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EDC</span>                 <span style="color:#008900">STR</span>             <span style="color:#008900">W8</span>, [<span style="color:#008900">SP</span>,#0x30+var_1C]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EE0</span>                 <span style="color:#008900">STR</span>             <span style="color:#008900">X1</span>, [<span style="color:#008900">SP</span>,#0x30+var_28]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EE4</span>                 <span style="color:#008900">BL</span>              <span style="color:#008900">_printf</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// IDA伪代码
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#ec0000">__cdecl</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>argv, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>envp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&#34;+&#34; TO EXPAND]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v4 <span style="color:#ec0000">=</span> <span style="color:#008900">104</span>;
</span></span><span style="display:flex;"><span>  v5 <span style="color:#ec0000">=</span> <span style="color:#008900">101</span>;
</span></span><span style="display:flex;"><span>  v6 <span style="color:#ec0000">=</span> <span style="color:#008900">108</span>;
</span></span><span style="display:flex;"><span>  v7 <span style="color:#ec0000">=</span> <span style="color:#008900">108</span>;
</span></span><span style="display:flex;"><span>  v8 <span style="color:#ec0000">=</span> <span style="color:#008900">111</span>;
</span></span><span style="display:flex;"><span>  v9 <span style="color:#ec0000">=</span> <span style="color:#008900">119</span>;
</span></span><span style="display:flex;"><span>  v10 <span style="color:#ec0000">=</span> <span style="color:#008900">111</span>;
</span></span><span style="display:flex;"><span>  v11 <span style="color:#ec0000">=</span> <span style="color:#008900">114</span>;
</span></span><span style="display:flex;"><span>  v12 <span style="color:#ec0000">=</span> <span style="color:#008900">108</span>;
</span></span><span style="display:flex;"><span>  v13 <span style="color:#ec0000">=</span> <span style="color:#008900">100</span>;
</span></span><span style="display:flex;"><span>  printf(<span style="color:#ec0000">&amp;</span>v4);
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意：此结果为IDA7.0版生成，如果使用IDA7.7+则识别为strcpy</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>llvm15/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo15.dylib -o /tmp/1.bin /tmp/1.cpp 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F06</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_13</span>], <span style="color:#008900">68</span><span style="color:#008900">h</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F0A</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_12</span>], <span style="color:#008900">65</span><span style="color:#008900">h</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F0E</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_11</span>], <span style="color:#008900">6</span><span style="color:#008900">Ch</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F12</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_10</span>], <span style="color:#008900">6</span><span style="color:#008900">Ch</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F16</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_F</span>], <span style="color:#008900">6</span><span style="color:#008900">Fh</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F1A</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_E</span>], <span style="color:#008900">77</span><span style="color:#008900">h</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F1E</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_D</span>], <span style="color:#008900">6</span><span style="color:#008900">Fh</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F22</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_C</span>], <span style="color:#008900">72</span><span style="color:#008900">h</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F26</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_B</span>], <span style="color:#008900">6</span><span style="color:#008900">Ch</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F2A</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_A</span>], <span style="color:#008900">64</span><span style="color:#008900">h</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F2E</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_9</span>], <span style="color:#008900">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F32</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_18</span>], <span style="color:#008900">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F39</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_1C</span>], <span style="color:#008900">edi</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F3C</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_28</span>], <span style="color:#008900">rsi</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F40</span>                 <span style="color:#008900">lea</span>     <span style="color:#008900">rdi</span>, [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_13</span>] ; char *
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F44</span>                 <span style="color:#008900">mov</span>     <span style="color:#008900">al</span>, <span style="color:#008900">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F46</span>                 <span style="color:#008900">call</span>    <span style="color:#008900">_printf</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// IDA伪代码
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#ec0000">__cdecl</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>argv, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>envp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&#34;+&#34; TO EXPAND]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  v4 <span style="color:#ec0000">=</span> <span style="color:#008900">104</span>;
</span></span><span style="display:flex;"><span>  v5 <span style="color:#ec0000">=</span> <span style="color:#008900">101</span>;
</span></span><span style="display:flex;"><span>  v6 <span style="color:#ec0000">=</span> <span style="color:#008900">108</span>;
</span></span><span style="display:flex;"><span>  v7 <span style="color:#ec0000">=</span> <span style="color:#008900">108</span>;
</span></span><span style="display:flex;"><span>  v8 <span style="color:#ec0000">=</span> <span style="color:#008900">111</span>;
</span></span><span style="display:flex;"><span>  v9 <span style="color:#ec0000">=</span> <span style="color:#008900">119</span>;
</span></span><span style="display:flex;"><span>  v10 <span style="color:#ec0000">=</span> <span style="color:#008900">111</span>;
</span></span><span style="display:flex;"><span>  v11 <span style="color:#ec0000">=</span> <span style="color:#008900">114</span>;
</span></span><span style="display:flex;"><span>  v12 <span style="color:#ec0000">=</span> <span style="color:#008900">108</span>;
</span></span><span style="display:flex;"><span>  v13 <span style="color:#ec0000">=</span> <span style="color:#008900">100</span>;
</span></span><span style="display:flex;"><span>  v14 <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>  printf(<span style="color:#ec0000">&amp;</span>v4, argv, envp);
</span></span><span style="display:flex;"><span>  result <span style="color:#ec0000">=</span> __stack_chk_guard;
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> ( __stack_chk_guard <span style="color:#ec0000">==</span> v15 )
</span></span><span style="display:flex;"><span>    result <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译为Release</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>llvm15/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk iphoneos --show-sdk-path<span style="color:#008900">`</span> -arch arm64 -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo15.dylib -o /tmp/1.bin /tmp/1.cpp -O3
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">ED8</span>                 <span style="color:#008900">LDR</span>             <span style="color:#008900">D0</span>, <span style="color:#ec0000">=</span><span style="color:#008900">0x726F776F6C6C6568</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EDC</span>                 <span style="color:#008900">STR</span>             <span style="color:#008900">D0</span>, [<span style="color:#008900">SP</span>,#0x20+var_18]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EE0</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W8</span>, #0x646C
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EE4</span>                 <span style="color:#008900">STRH</span>            <span style="color:#008900">W8</span>, [<span style="color:#008900">SP</span>,#0x20+var_10]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EE8</span>                 <span style="color:#008900">STRB</span>            <span style="color:#008900">WZR</span>, [<span style="color:#008900">SP</span>,#0x20+var_E]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EEC</span>                 <span style="color:#008900">ADD</span>             <span style="color:#008900">X0</span>, <span style="color:#008900">SP</span>, #0x20+var_18 ; char *
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EF0</span>                 <span style="color:#008900">BL</span>              <span style="color:#008900">_printf</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// IDA伪代码
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#ec0000">__cdecl</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>argv, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>envp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&#34;+&#34; TO EXPAND]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  strcpy(v4, <span style="color:#008900">&#34;helloworld&#34;</span>);
</span></span><span style="display:flex;"><span>  result <span style="color:#ec0000">=</span> printf(v4, argv, envp);
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> ( __stack_chk_guard <span style="color:#ec0000">==</span> v5 )
</span></span><span style="display:flex;"><span>    result <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意：此时IDA已经把上述指令集识别成内部函数的strcpy, 这里strcpy非动态库里的那个函数</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>llvm15/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo15.dylib -o /tmp/1.bin /tmp/1.cpp -O3
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F46</span>                 <span style="color:#008900">mov</span>     <span style="color:#008900">rax</span>, <span style="color:#008900">726</span><span style="color:#008900">F776F6C6C6568h</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F50</span>                 <span style="color:#008900">mov</span>     <span style="color:#008900">qword</span> <span style="color:#008900">ptr</span> [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_18</span>], <span style="color:#008900">rax</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F54</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_10</span>], <span style="color:#008900">646</span><span style="color:#008900">Ch</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F5A</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_E</span>], <span style="color:#008900">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F5E</span>                 <span style="color:#008900">lea</span>     <span style="color:#008900">rdi</span>, [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_18</span>] ; char *
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F62</span>                 <span style="color:#008900">xor</span>     <span style="color:#008900">eax</span>, <span style="color:#008900">eax</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F64</span>                 <span style="color:#008900">call</span>    <span style="color:#008900">_printf</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// IDA伪代码
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#ec0000">__cdecl</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>argv, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>envp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&#34;+&#34; TO EXPAND]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  strcpy(v4, <span style="color:#008900">&#34;helloworld&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(v4, argv, envp);
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> ( __stack_chk_guard <span style="color:#ec0000">!=</span> v5 )
</span></span><span style="display:flex;"><span>    __stack_chk_fail();
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>介入时机指定为EP_OptimizerLast，编译为Release</p>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>llvm15/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk iphoneos --show-sdk-path<span style="color:#008900">`</span> -arch arm64 -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo15.dylib -o /tmp/1.bin /tmp/1.cpp -O3
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">ED4</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">X8</span>, #0x6568
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">ED8</span>                 <span style="color:#008900">MOVK</span>            <span style="color:#008900">X8</span>, #0x6C6C,LSL#16
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EDC</span>                 <span style="color:#008900">MOVK</span>            <span style="color:#008900">X8</span>, #0x776F,LSL#32
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EE0</span>                 <span style="color:#008900">MOVK</span>            <span style="color:#008900">X8</span>, #0x726F,LSL#48
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EE4</span>                 <span style="color:#008900">STUR</span>            <span style="color:#008900">X8</span>, [<span style="color:#008900">SP</span>,#0x20+var_13]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EE8</span>                 <span style="color:#008900">MOV</span>             <span style="color:#008900">W8</span>, #0x646C
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EEC</span>                 <span style="color:#008900">STURH</span>           <span style="color:#008900">W8</span>, [<span style="color:#008900">SP</span>,#0x20+var_B]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EF0</span>                 <span style="color:#008900">STRB</span>            <span style="color:#008900">WZR</span>, [<span style="color:#008900">SP</span>,#0x20+var_9]
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EF4</span>                 <span style="color:#008900">ADD</span>             <span style="color:#008900">X0</span>, <span style="color:#008900">SP</span>, #0x20+var_13 ; char *
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100007</span><span style="color:#5f5fff">EF8</span>                 <span style="color:#008900">BL</span>              <span style="color:#008900">_printf</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// IDA伪代码
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#ec0000">__cdecl</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>argv, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>envp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&#34;+&#34; TO EXPAND]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  strcpy(v4, <span style="color:#008900">&#34;helloworld&#34;</span>);
</span></span><span style="display:flex;"><span>  result <span style="color:#ec0000">=</span> printf(v4, argv, envp);
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> ( __stack_chk_guard <span style="color:#ec0000">==</span> v5 )
</span></span><span style="display:flex;"><span>    result <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>llvm15/build/bin/clang -isysroot <span style="color:#008900">`</span>xcrun --sdk macosx --show-sdk-path<span style="color:#008900">`</span> -fpass-plugin<span style="color:#ec0000">=</span>build/MyPassDemo15.dylib -o /tmp/1.bin /tmp/1.cpp -O3
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F46</span>                 <span style="color:#008900">mov</span>     <span style="color:#008900">rax</span>, <span style="color:#008900">726</span><span style="color:#008900">F776F6C6C6568h</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F50</span>                 <span style="color:#008900">mov</span>     <span style="color:#008900">qword</span> <span style="color:#008900">ptr</span> [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_13</span>], <span style="color:#008900">rax</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F54</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_B</span>], <span style="color:#008900">646</span><span style="color:#008900">Ch</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F5A</span>                 <span style="color:#008900">mov</span>     [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_9</span>], <span style="color:#008900">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F5E</span>                 <span style="color:#008900">lea</span>     <span style="color:#008900">rdi</span>, [<span style="color:#008900">rbp</span><span style="color:#ec0000">+</span><span style="color:#008900">var_13</span>] ; char *
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F62</span>                 <span style="color:#008900">xor</span>     <span style="color:#008900">eax</span>, <span style="color:#008900">eax</span>
</span></span><span style="display:flex;"><span><span style="color:#ec0000">__text:</span><span style="color:#ec0000">0000000100003</span><span style="color:#5f5fff">F64</span>                 <span style="color:#008900">call</span>    <span style="color:#008900">_printf</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>// IDA伪代码
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">int</span> <span style="color:#ec0000">__cdecl</span> <span style="color:#5f5fff">main</span>(<span style="color:#5f5fff">int</span> argc, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>argv, <span style="color:#ec0000">const</span> <span style="color:#5f5fff">char</span> <span style="color:#ec0000">**</span>envp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-&#34;+&#34; TO EXPAND]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  strcpy(v4, <span style="color:#008900">&#34;helloworld&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(v4, argv, envp);
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> ( __stack_chk_guard <span style="color:#ec0000">!=</span> v5 )
</span></span><span style="display:flex;"><span>    __stack_chk_fail();
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="控制流级别的混淆">控制流级别的混淆</h2>
<h3 id="hikari-splitbasicblock模块分析">Hikari SplitBasicBlock模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5f5fff">void</span> SplitBasicBlock<span style="color:#ec0000">::</span>split(Function <span style="color:#ec0000">*</span>f) {
</span></span><span style="display:flex;"><span>  std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;</span> origBB;
</span></span><span style="display:flex;"><span>  <span style="color:#5f5fff">int</span> splitN <span style="color:#ec0000">=</span> SplitNum;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Save all basic blocks
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">for</span> (Function<span style="color:#ec0000">::</span>iterator I <span style="color:#ec0000">=</span> f<span style="color:#ec0000">-&gt;</span>begin(), IE <span style="color:#ec0000">=</span> f<span style="color:#ec0000">-&gt;</span>end(); I <span style="color:#ec0000">!=</span> IE; <span style="color:#ec0000">++</span>I) {
</span></span><span style="display:flex;"><span>    origBB.push_back(<span style="color:#ec0000">&amp;*</span>I);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">for</span> (std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;::</span>iterator I <span style="color:#ec0000">=</span> origBB.begin(),
</span></span><span style="display:flex;"><span>                                           IE <span style="color:#ec0000">=</span> origBB.end();
</span></span><span style="display:flex;"><span>       I <span style="color:#ec0000">!=</span> IE; <span style="color:#ec0000">++</span>I) {
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>curr <span style="color:#ec0000">=</span> <span style="color:#ec0000">*</span>I;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // No need to split a 1 inst bb
</span></span><span style="display:flex;"><span>    // Or ones containing a PHI node
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (curr<span style="color:#ec0000">-&gt;</span>size() <span style="color:#ec0000">&lt;</span> <span style="color:#008900">2</span> <span style="color:#ec0000">||</span> containsPHI(curr)) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Check splitN and current BB size
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> ((size_t)splitN <span style="color:#ec0000">&gt;</span> curr<span style="color:#ec0000">-&gt;</span>size()) {
</span></span><span style="display:flex;"><span>      splitN <span style="color:#ec0000">=</span> curr<span style="color:#ec0000">-&gt;</span>size() <span style="color:#ec0000">-</span> <span style="color:#008900">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Generate splits point
</span></span><span style="display:flex;"><span>    std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">int</span><span style="color:#ec0000">&gt;</span> test;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">1</span>; i <span style="color:#ec0000">&lt;</span> curr<span style="color:#ec0000">-&gt;</span>size(); <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>      test.push_back(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Shuffle
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (test.size() <span style="color:#ec0000">!=</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>      shuffle(test);
</span></span><span style="display:flex;"><span>      std<span style="color:#ec0000">::</span>sort(test.begin(), test.begin() <span style="color:#ec0000">+</span> splitN);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Split
</span></span><span style="display:flex;"><span>    BasicBlock<span style="color:#ec0000">::</span>iterator it <span style="color:#ec0000">=</span> curr<span style="color:#ec0000">-&gt;</span>begin();
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>toSplit <span style="color:#ec0000">=</span> curr;
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">int</span> last <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">int</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> splitN; <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">int</span> j <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; j <span style="color:#ec0000">&lt;</span> test[i] <span style="color:#ec0000">-</span> last; <span style="color:#ec0000">++</span>j) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">++</span>it;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      last <span style="color:#ec0000">=</span> test[i];
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (toSplit<span style="color:#ec0000">-&gt;</span>size() <span style="color:#ec0000">&lt;</span> <span style="color:#008900">2</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>      toSplit <span style="color:#ec0000">=</span> toSplit<span style="color:#ec0000">-&gt;</span>splitBasicBlock(it, toSplit<span style="color:#ec0000">-&gt;</span>getName() <span style="color:#ec0000">+</span> <span style="color:#008900">&#34;.split&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">++</span>Split;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}
</code></pre><pre class="mermaid">flowchart LR
A([entry]) --> B([if.then])
A([entry]) --> C([if.end])
B([if.then]) --> C([if.end])
C([if.end]) --> ret([ret])
</pre>
<p>已混淆IR(<code>-mllvm -enable-splitobf</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  br label %entry.split

entry.split:                                      ; preds = %entry
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  br label %entry.split.split

entry.split.split:                                ; preds = %entry.split
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry.split.split
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  br label %if.then.split

if.then.split:                                    ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %if.then.split, %entry.split.split
  ret i32 0
}
</code></pre><pre class="mermaid">flowchart LR
A([entry]) --> B([entry.split])
B([entry.split]) --> C([entry.split.split])
C([entry.split.split]) --> D([if.then])
C([entry.split.split]) --> E([if.end])
D([if.then]) --> F([if.then.split])
F([if.then.split]) --> E([if.end])
E([if.end]) --> ret([ret])
</pre>
<p>  split是BasicBlock层的混淆，可以将函数的基本块随机划分为若干个更小的基本块，单独使用并无作用，但可用于增强其他基于块的混淆方式(如fla)</p>
<h3 id="hikari-flattening模块分析">Hikari Flattening模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5f5fff">bool</span> Flattening<span style="color:#ec0000">::</span>flatten(Function <span style="color:#ec0000">*</span>f) {
</span></span><span style="display:flex;"><span>  vector<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;</span> origBB;
</span></span><span style="display:flex;"><span>  BasicBlock <span style="color:#ec0000">*</span>loopEntry;
</span></span><span style="display:flex;"><span>  BasicBlock <span style="color:#ec0000">*</span>loopEnd;
</span></span><span style="display:flex;"><span>  LoadInst <span style="color:#ec0000">*</span>load;
</span></span><span style="display:flex;"><span>  SwitchInst <span style="color:#ec0000">*</span>switchI;
</span></span><span style="display:flex;"><span>  AllocaInst <span style="color:#ec0000">*</span>switchVar;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // SCRAMBLER
</span></span><span style="display:flex;"><span>  std<span style="color:#ec0000">::</span>map<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint32_t</span>,<span style="color:#5f5fff">uint32_t</span><span style="color:#ec0000">&gt;</span> scrambling_key;
</span></span><span style="display:flex;"><span>  // END OF SCRAMBLER
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Lower switch
</span></span><span style="display:flex;"><span>  FunctionPass <span style="color:#ec0000">*</span>lower <span style="color:#ec0000">=</span> createLowerSwitchPass();
</span></span><span style="display:flex;"><span>  lower<span style="color:#ec0000">-&gt;</span>runOnFunction(<span style="color:#ec0000">*</span>f);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Save all original BB
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">for</span> (Function<span style="color:#ec0000">::</span>iterator i <span style="color:#ec0000">=</span> f<span style="color:#ec0000">-&gt;</span>begin(); i <span style="color:#ec0000">!=</span> f<span style="color:#ec0000">-&gt;</span>end(); <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>tmp <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;*</span>i;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (tmp<span style="color:#ec0000">-&gt;</span>isEHPad() <span style="color:#ec0000">||</span> tmp<span style="color:#ec0000">-&gt;</span>isLandingPad()) {
</span></span><span style="display:flex;"><span>          errs()<span style="color:#ec0000">&lt;&lt;</span>f<span style="color:#ec0000">-&gt;</span>getName()<span style="color:#ec0000">&lt;&lt;</span><span style="color:#008900">&#34; Contains Exception Handing Instructions and is unsupported for flattening in the open-source version of Hikari.</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    origBB.push_back(tmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>bb <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;*</span>i;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>isa<span style="color:#ec0000">&lt;</span>BranchInst<span style="color:#ec0000">&gt;</span>(bb<span style="color:#ec0000">-&gt;</span>getTerminator()) <span style="color:#ec0000">&amp;&amp;</span> <span style="color:#ec0000">!</span>isa<span style="color:#ec0000">&lt;</span>ReturnInst<span style="color:#ec0000">&gt;</span>(bb<span style="color:#ec0000">-&gt;</span>getTerminator())) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Nothing to flatten
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> (origBB.size() <span style="color:#ec0000">&lt;=</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Remove first BB
</span></span><span style="display:flex;"><span>  origBB.erase(origBB.begin());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Get a pointer on the first BB
</span></span><span style="display:flex;"><span>  Function<span style="color:#ec0000">::</span>iterator tmp <span style="color:#ec0000">=</span> f<span style="color:#ec0000">-&gt;</span>begin(); //++tmp;
</span></span><span style="display:flex;"><span>  BasicBlock <span style="color:#ec0000">*</span>insert <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;*</span>tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // If main begin with an if
</span></span><span style="display:flex;"><span>  BranchInst <span style="color:#ec0000">*</span>br <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> (isa<span style="color:#ec0000">&lt;</span>BranchInst<span style="color:#ec0000">&gt;</span>(insert<span style="color:#ec0000">-&gt;</span>getTerminator())) {
</span></span><span style="display:flex;"><span>    br <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>BranchInst<span style="color:#ec0000">&gt;</span>(insert<span style="color:#ec0000">-&gt;</span>getTerminator());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">if</span> ((br <span style="color:#ec0000">!=</span> <span style="color:#ec0000">NULL</span> <span style="color:#ec0000">&amp;&amp;</span> br<span style="color:#ec0000">-&gt;</span>isConditional()) <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>      insert<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getNumSuccessors() <span style="color:#ec0000">&gt;</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>    BasicBlock<span style="color:#ec0000">::</span>iterator i <span style="color:#ec0000">=</span> insert<span style="color:#ec0000">-&gt;</span>end();
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">--</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (insert<span style="color:#ec0000">-&gt;</span>size() <span style="color:#ec0000">&gt;</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">--</span>i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>tmpBB <span style="color:#ec0000">=</span> insert<span style="color:#ec0000">-&gt;</span>splitBasicBlock(i, <span style="color:#008900">&#34;first&#34;</span>);
</span></span><span style="display:flex;"><span>    origBB.insert(origBB.begin(), tmpBB);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Remove jump
</span></span><span style="display:flex;"><span>  Instruction<span style="color:#ec0000">*</span> oldTerm<span style="color:#ec0000">=</span>insert<span style="color:#ec0000">-&gt;</span>getTerminator();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Create switch variable and set as it
</span></span><span style="display:flex;"><span>  switchVar <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">new</span> AllocaInst(Type<span style="color:#ec0000">::</span>getInt32Ty(f<span style="color:#ec0000">-&gt;</span>getContext()), <span style="color:#008900">0</span>, <span style="color:#008900">&#34;switchVar&#34;</span>,oldTerm);
</span></span><span style="display:flex;"><span>  oldTerm<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">new</span> <span style="color:#5f5fff">StoreInst</span>(
</span></span><span style="display:flex;"><span>      ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(f<span style="color:#ec0000">-&gt;</span>getContext()),
</span></span><span style="display:flex;"><span>                       llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>scramble32(<span style="color:#008900">0</span>, scrambling_key)),
</span></span><span style="display:flex;"><span>      switchVar, insert);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Create main loop
</span></span><span style="display:flex;"><span>  loopEntry <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(f<span style="color:#ec0000">-&gt;</span>getContext(), <span style="color:#008900">&#34;loopEntry&#34;</span>, f, insert);
</span></span><span style="display:flex;"><span>  loopEnd <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(f<span style="color:#ec0000">-&gt;</span>getContext(), <span style="color:#008900">&#34;loopEnd&#34;</span>, f, insert);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  load <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> LoadInst(switchVar, <span style="color:#008900">&#34;switchVar&#34;</span>, loopEntry);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Move first BB on top
</span></span><span style="display:flex;"><span>  insert<span style="color:#ec0000">-&gt;</span>moveBefore(loopEntry);
</span></span><span style="display:flex;"><span>  BranchInst<span style="color:#ec0000">::</span>Create(loopEntry, insert);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // loopEnd jump to loopEntry
</span></span><span style="display:flex;"><span>  BranchInst<span style="color:#ec0000">::</span>Create(loopEntry, loopEnd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  BasicBlock <span style="color:#ec0000">*</span>swDefault <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>      BasicBlock<span style="color:#ec0000">::</span>Create(f<span style="color:#ec0000">-&gt;</span>getContext(), <span style="color:#008900">&#34;switchDefault&#34;</span>, f, loopEnd);
</span></span><span style="display:flex;"><span>  BranchInst<span style="color:#ec0000">::</span>Create(loopEnd, swDefault);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Create switch instruction itself and set condition
</span></span><span style="display:flex;"><span>  switchI <span style="color:#ec0000">=</span> SwitchInst<span style="color:#ec0000">::</span>Create(<span style="color:#ec0000">&amp;*</span>f<span style="color:#ec0000">-&gt;</span>begin(), swDefault, <span style="color:#008900">0</span>, loopEntry);
</span></span><span style="display:flex;"><span>  switchI<span style="color:#ec0000">-&gt;</span>setCondition(load);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Remove branch jump from 1st BB and make a jump to the while
</span></span><span style="display:flex;"><span>  f<span style="color:#ec0000">-&gt;</span>begin()<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  BranchInst<span style="color:#ec0000">::</span>Create(loopEntry, <span style="color:#ec0000">&amp;*</span>f<span style="color:#ec0000">-&gt;</span>begin());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Put all BB in the switch
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">for</span> (vector<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;::</span>iterator b <span style="color:#ec0000">=</span> origBB.begin(); b <span style="color:#ec0000">!=</span> origBB.end();
</span></span><span style="display:flex;"><span>       <span style="color:#ec0000">++</span>b) {
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>i <span style="color:#ec0000">=</span> <span style="color:#ec0000">*</span>b;
</span></span><span style="display:flex;"><span>    ConstantInt <span style="color:#ec0000">*</span>numCase <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Move the BB inside the switch (only visual, no code logic)
</span></span><span style="display:flex;"><span>    i<span style="color:#ec0000">-&gt;</span>moveBefore(loopEnd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Add case to switch
</span></span><span style="display:flex;"><span>    numCase <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(ConstantInt<span style="color:#ec0000">::</span>get(
</span></span><span style="display:flex;"><span>        switchI<span style="color:#ec0000">-&gt;</span>getCondition()<span style="color:#ec0000">-&gt;</span>getType(),
</span></span><span style="display:flex;"><span>        llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>scramble32(switchI<span style="color:#ec0000">-&gt;</span>getNumCases(), scrambling_key)));
</span></span><span style="display:flex;"><span>    switchI<span style="color:#ec0000">-&gt;</span>addCase(numCase, i);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Recalculate switchVar
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">for</span> (vector<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;::</span>iterator b <span style="color:#ec0000">=</span> origBB.begin(); b <span style="color:#ec0000">!=</span> origBB.end();
</span></span><span style="display:flex;"><span>       <span style="color:#ec0000">++</span>b) {
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>i <span style="color:#ec0000">=</span> <span style="color:#ec0000">*</span>b;
</span></span><span style="display:flex;"><span>    ConstantInt <span style="color:#ec0000">*</span>numCase <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Ret BB
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (i<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getNumSuccessors() <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // If it&#39;s a non-conditional jump
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (i<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getNumSuccessors() <span style="color:#ec0000">==</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>      // Get successor and delete terminator
</span></span><span style="display:flex;"><span>      BasicBlock <span style="color:#ec0000">*</span>succ <span style="color:#ec0000">=</span> i<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>      i<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      // Get next case
</span></span><span style="display:flex;"><span>      numCase <span style="color:#ec0000">=</span> switchI<span style="color:#ec0000">-&gt;</span>findCaseDest(succ);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      // If next case == default case (switchDefault)
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (numCase <span style="color:#ec0000">==</span> <span style="color:#ec0000">NULL</span>) {
</span></span><span style="display:flex;"><span>        numCase <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(
</span></span><span style="display:flex;"><span>            ConstantInt<span style="color:#ec0000">::</span>get(switchI<span style="color:#ec0000">-&gt;</span>getCondition()<span style="color:#ec0000">-&gt;</span>getType(),
</span></span><span style="display:flex;"><span>                             llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>scramble32(
</span></span><span style="display:flex;"><span>                                 switchI<span style="color:#ec0000">-&gt;</span>getNumCases() <span style="color:#ec0000">-</span> <span style="color:#008900">1</span>, scrambling_key)));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      // Update switchVar and jump to the end of loop
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">new</span> <span style="color:#5f5fff">StoreInst</span>(numCase, load<span style="color:#ec0000">-&gt;</span>getPointerOperand(), i);
</span></span><span style="display:flex;"><span>      BranchInst<span style="color:#ec0000">::</span>Create(loopEnd, i);
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // If it&#39;s a conditional jump
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (i<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getNumSuccessors() <span style="color:#ec0000">==</span> <span style="color:#008900">2</span>) {
</span></span><span style="display:flex;"><span>      // Get next cases
</span></span><span style="display:flex;"><span>      ConstantInt <span style="color:#ec0000">*</span>numCaseTrue <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          switchI<span style="color:#ec0000">-&gt;</span>findCaseDest(i<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>));
</span></span><span style="display:flex;"><span>      ConstantInt <span style="color:#ec0000">*</span>numCaseFalse <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          switchI<span style="color:#ec0000">-&gt;</span>findCaseDest(i<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      // Check if next case == default case (switchDefault)
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (numCaseTrue <span style="color:#ec0000">==</span> <span style="color:#ec0000">NULL</span>) {
</span></span><span style="display:flex;"><span>        numCaseTrue <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(
</span></span><span style="display:flex;"><span>            ConstantInt<span style="color:#ec0000">::</span>get(switchI<span style="color:#ec0000">-&gt;</span>getCondition()<span style="color:#ec0000">-&gt;</span>getType(),
</span></span><span style="display:flex;"><span>                             llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>scramble32(
</span></span><span style="display:flex;"><span>                                 switchI<span style="color:#ec0000">-&gt;</span>getNumCases() <span style="color:#ec0000">-</span> <span style="color:#008900">1</span>, scrambling_key)));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (numCaseFalse <span style="color:#ec0000">==</span> <span style="color:#ec0000">NULL</span>) {
</span></span><span style="display:flex;"><span>        numCaseFalse <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(
</span></span><span style="display:flex;"><span>            ConstantInt<span style="color:#ec0000">::</span>get(switchI<span style="color:#ec0000">-&gt;</span>getCondition()<span style="color:#ec0000">-&gt;</span>getType(),
</span></span><span style="display:flex;"><span>                             llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>scramble32(
</span></span><span style="display:flex;"><span>                                 switchI<span style="color:#ec0000">-&gt;</span>getNumCases() <span style="color:#ec0000">-</span> <span style="color:#008900">1</span>, scrambling_key)));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      // Create a SelectInst
</span></span><span style="display:flex;"><span>      BranchInst <span style="color:#ec0000">*</span>br <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>BranchInst<span style="color:#ec0000">&gt;</span>(i<span style="color:#ec0000">-&gt;</span>getTerminator());
</span></span><span style="display:flex;"><span>      SelectInst <span style="color:#ec0000">*</span>sel <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          SelectInst<span style="color:#ec0000">::</span>Create(br<span style="color:#ec0000">-&gt;</span>getCondition(), numCaseTrue, numCaseFalse, <span style="color:#008900">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>                             i<span style="color:#ec0000">-&gt;</span>getTerminator());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      // Erase terminator
</span></span><span style="display:flex;"><span>      i<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>      // Update switchVar and jump to the end of loop
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">new</span> <span style="color:#5f5fff">StoreInst</span>(sel, load<span style="color:#ec0000">-&gt;</span>getPointerOperand(), i);
</span></span><span style="display:flex;"><span>      BranchInst<span style="color:#ec0000">::</span>Create(loopEnd, i);
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  errs()<span style="color:#ec0000">&lt;&lt;</span><span style="color:#008900">&#34;Fixing Stack</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>  fixStack(f);
</span></span><span style="display:flex;"><span>  errs()<span style="color:#ec0000">&lt;&lt;</span><span style="color:#008900">&#34;Fixed Stack</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @puts(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}
</code></pre><pre class="mermaid">flowchart LR
A([entry]) --> B([if.then])
A([entry]) --> C([if.end])
B([if.then]) --> C([if.end])
C([if.end]) --> ret([ret])
</pre>
<p>已混淆IR(<code>-mllvm -enable-cffobf</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %.reg2mem = alloca i32
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  store i32 %0, i32* %.reg2mem
  %switchVar = alloca i32
  store i32 175153184, i32* %switchVar
  br label %loopEntry

loopEntry:                                        ; preds = %entry, %loopEnd
  %switchVar1 = load i32, i32* %switchVar
  switch i32 %switchVar1, label %switchDefault [
    i32 175153184, label %first
    i32 -210782820, label %if.then
    i32 165052502, label %if.end
  ]

switchDefault:                                    ; preds = %loopEntry
  br label %loopEnd

first:                                            ; preds = %loopEntry
  %.reload = load volatile i32, i32* %.reg2mem
  %cmp = icmp eq i32 %.reload, 1
  %1 = select i1 %cmp, i32 -210782820, i32 165052502
  store i32 %1, i32* %switchVar
  br label %loopEnd

if.then:                                          ; preds = %loopEntry
  %call = call i32 @puts(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0))
  store i32 165052502, i32* %switchVar
  br label %loopEnd

if.end:                                           ; preds = %loopEntry
  ret i32 0

loopEnd:                                          ; preds = %if.then, %first, %switchDefault
  br label %loopEntry
}
</code></pre><pre class="mermaid">flowchart LR
A([entry]) --> B([loopEntry])
B([loopEntry]) --> C([first])
B([loopEntry]) --> D([if.then])
B([loopEntry]) --> G([if.end])
B([loopEntry]) --> E([switchDefault])
C([first]) --> F([loopEnd])
D([if.then]) --> F([loopEnd])
E([switchDefault]) --> F([loopEnd])
F([loopEnd]) --> B([loopEntry])
G([if.end]) --> ret([ret])
</pre>
<p>  fla是基于BasicBlock的混淆，可以将顺序执行的基本块转换为循环结构，使之平坦化</p>
<h3 id="pluto-flattening模块分析">Pluto Flattening模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PreservedAnalyses Pluto<span style="color:#ec0000">::</span>Flattening<span style="color:#ec0000">::</span>run(Function <span style="color:#ec0000">&amp;</span>F, FunctionAnalysisManager <span style="color:#ec0000">&amp;</span>AM) {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">auto</span> <span style="color:#ec0000">&amp;</span>context <span style="color:#ec0000">=</span> F.getContext();
</span></span><span style="display:flex;"><span>    IRBuilder<span style="color:#ec0000">&lt;&gt;</span> builder(context);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // No need to do flattening if only there is only one block
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (F.size() <span style="color:#ec0000">&lt;=</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">return</span> PreservedAnalyses<span style="color:#ec0000">::</span>all();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;</span> origBB;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">BB</span> : F) {
</span></span><span style="display:flex;"><span>        origBB.push_back(<span style="color:#ec0000">&amp;</span>BB);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">&amp;</span>entryBB <span style="color:#ec0000">=</span> F.getEntryBlock();
</span></span><span style="display:flex;"><span>    origBB.erase(origBB.begin());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // If the entry block ends with a conditional branch, seperate it as a new block
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (entryBB.getTerminator()<span style="color:#ec0000">-&gt;</span>getNumSuccessors() <span style="color:#ec0000">&gt;</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>        BasicBlock <span style="color:#ec0000">*</span>newBB <span style="color:#ec0000">=</span> entryBB.splitBasicBlock(entryBB.getTerminator(), <span style="color:#008900">&#34;newBB&#34;</span>);
</span></span><span style="display:flex;"><span>        origBB.insert(origBB.begin(), newBB);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // This is for register demotion
</span></span><span style="display:flex;"><span>    // The return value of the invoke instruction will be store into stack in the bridge block
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock <span style="color:#ec0000">*</span><span style="color:#ec0000">BB</span> : origBB) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (InvokeInst <span style="color:#ec0000">*</span>invoke <span style="color:#ec0000">=</span> dyn_cast_or_null<span style="color:#ec0000">&lt;</span>InvokeInst<span style="color:#ec0000">&gt;</span>(BB<span style="color:#ec0000">-&gt;</span>getTerminator())) {
</span></span><span style="display:flex;"><span>            BasicBlock <span style="color:#ec0000">*</span>bridgeBB <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;bridgeBB&#34;</span>, <span style="color:#ec0000">&amp;</span>F, invoke<span style="color:#ec0000">-&gt;</span>getNormalDest());
</span></span><span style="display:flex;"><span>            invoke<span style="color:#ec0000">-&gt;</span>getNormalDest()<span style="color:#ec0000">-&gt;</span>replacePhiUsesWith(BB, bridgeBB);
</span></span><span style="display:flex;"><span>            builder.SetInsertPoint(bridgeBB);
</span></span><span style="display:flex;"><span>            builder.CreateBr(invoke<span style="color:#ec0000">-&gt;</span>getNormalDest());
</span></span><span style="display:flex;"><span>            invoke<span style="color:#ec0000">-&gt;</span>setNormalDest(bridgeBB);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Create the dispatch block and return block
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>dispatchBB <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;dispatchBB&#34;</span>, <span style="color:#ec0000">&amp;</span>F, <span style="color:#ec0000">&amp;</span>entryBB);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>returnBB <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;returnBB&#34;</span>, <span style="color:#ec0000">&amp;</span>F, <span style="color:#ec0000">&amp;</span>entryBB);
</span></span><span style="display:flex;"><span>    BranchInst<span style="color:#ec0000">::</span>Create(dispatchBB, returnBB);
</span></span><span style="display:flex;"><span>    entryBB.moveBefore(dispatchBB);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Make the entry block go to the dispatchBB directly
</span></span><span style="display:flex;"><span>    entryBB.getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>    BranchInst <span style="color:#ec0000">*</span>brDispatchBB <span style="color:#ec0000">=</span> BranchInst<span style="color:#ec0000">::</span>Create(dispatchBB, <span style="color:#ec0000">&amp;</span>entryBB);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(brDispatchBB);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Now insert an alloca and a store instruction at the end of entry block, and initialize the switch variable with
</span></span><span style="display:flex;"><span>    // a random value.
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">uint32_t</span> randNum <span style="color:#ec0000">=</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t();
</span></span><span style="display:flex;"><span>    AllocaInst <span style="color:#ec0000">*</span>swVarPtr <span style="color:#ec0000">=</span> builder.CreateAlloca(Type<span style="color:#ec0000">::</span>getInt32Ty(context), <span style="color:#008900">0</span>, <span style="color:#008900">&#34;swVar.ptr&#34;</span>);
</span></span><span style="display:flex;"><span>    builder.CreateStore(ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(context), randNum), swVarPtr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Insert a load instruction at the end of dispatch block
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(dispatchBB);
</span></span><span style="display:flex;"><span>    LoadInst <span style="color:#ec0000">*</span>swVar <span style="color:#ec0000">=</span> builder.CreateLoad(Type<span style="color:#ec0000">::</span>getInt32Ty(context), swVarPtr, <span style="color:#ec0000">false</span>, <span style="color:#008900">&#34;swVar&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Insert a switch instruction to dispatch blocks
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>swDefault <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(context, <span style="color:#008900">&#34;swDefault&#34;</span>, <span style="color:#ec0000">&amp;</span>F, returnBB);
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(swDefault);
</span></span><span style="display:flex;"><span>    builder.CreateBr(returnBB);
</span></span><span style="display:flex;"><span>    builder.SetInsertPoint(dispatchBB);
</span></span><span style="display:flex;"><span>    SwitchInst <span style="color:#ec0000">*</span>swInst <span style="color:#ec0000">=</span> builder.CreateSwitch(swVar, swDefault, origBB.size());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Record used random numbers to avoid depulicate case values in switch
</span></span><span style="display:flex;"><span>    std<span style="color:#ec0000">::</span>set<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">uint32_t</span><span style="color:#ec0000">&gt;</span> usedNum;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Insert original basic blocks before return block and assign a random case value for each one.
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock <span style="color:#ec0000">*</span><span style="color:#ec0000">BB</span> : origBB) {
</span></span><span style="display:flex;"><span>        // Do not add error handling blocks into switch
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (BB<span style="color:#ec0000">-&gt;</span>isEHPad()) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        usedNum.insert(randNum);
</span></span><span style="display:flex;"><span>        BB<span style="color:#ec0000">-&gt;</span>moveBefore(returnBB);
</span></span><span style="display:flex;"><span>        swInst<span style="color:#ec0000">-&gt;</span>addCase(ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(context), randNum), BB);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">do</span> {
</span></span><span style="display:flex;"><span>            randNum <span style="color:#ec0000">=</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t();
</span></span><span style="display:flex;"><span>        } <span style="color:#ec0000">while</span> (find(usedNum.begin(), usedNum.end(), randNum) <span style="color:#ec0000">!=</span> usedNum.end());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Insert a store instruction at the end of each block to modify swVar, and make them jump back to dispatch block.
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock <span style="color:#ec0000">*</span><span style="color:#ec0000">BB</span> : origBB) {
</span></span><span style="display:flex;"><span>        // Skip blocks with no successor
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (BB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getNumSuccessors() <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        // Branch
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">else</span> <span style="color:#5f5fff">if</span> (BB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getNumSuccessors() <span style="color:#ec0000">==</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>            BasicBlock <span style="color:#ec0000">*</span>sucBB <span style="color:#ec0000">=</span> BB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>            ConstantInt <span style="color:#ec0000">*</span>numCase <span style="color:#ec0000">=</span> swInst<span style="color:#ec0000">-&gt;</span>findCaseDest(sucBB);
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (numCase) {
</span></span><span style="display:flex;"><span>                <span style="color:#ec0000">if</span> (BranchInst <span style="color:#ec0000">*</span>br <span style="color:#ec0000">=</span> dyn_cast_or_null<span style="color:#ec0000">&lt;</span>BranchInst<span style="color:#ec0000">&gt;</span>(BB<span style="color:#ec0000">-&gt;</span>getTerminator())) {
</span></span><span style="display:flex;"><span>                    BB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>                    builder.SetInsertPoint(BB);
</span></span><span style="display:flex;"><span>                    builder.CreateStore(numCase, swVarPtr);
</span></span><span style="display:flex;"><span>                    builder.CreateBr(returnBB);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        // Conditional branch
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">else</span> <span style="color:#5f5fff">if</span> (BB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getNumSuccessors() <span style="color:#ec0000">==</span> <span style="color:#008900">2</span>) {
</span></span><span style="display:flex;"><span>            ConstantInt <span style="color:#ec0000">*</span>numIfTrue <span style="color:#ec0000">=</span> swInst<span style="color:#ec0000">-&gt;</span>findCaseDest(BB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>));
</span></span><span style="display:flex;"><span>            ConstantInt <span style="color:#ec0000">*</span>numIfFalse <span style="color:#ec0000">=</span> swInst<span style="color:#ec0000">-&gt;</span>findCaseDest(BB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">1</span>));
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (numIfTrue <span style="color:#ec0000">&amp;&amp;</span> numIfFalse) {
</span></span><span style="display:flex;"><span>                <span style="color:#ec0000">if</span> (BranchInst <span style="color:#ec0000">*</span>br <span style="color:#ec0000">=</span> dyn_cast_or_null<span style="color:#ec0000">&lt;</span>BranchInst<span style="color:#ec0000">&gt;</span>(BB<span style="color:#ec0000">-&gt;</span>getTerminator())) {
</span></span><span style="display:flex;"><span>                    Value <span style="color:#ec0000">*</span>cond <span style="color:#ec0000">=</span> br<span style="color:#ec0000">-&gt;</span>getCondition();
</span></span><span style="display:flex;"><span>                    builder.SetInsertPoint(BB);
</span></span><span style="display:flex;"><span>                    builder.CreateStore(builder.CreateSelect(cond, numIfTrue, numIfFalse), swVarPtr);
</span></span><span style="display:flex;"><span>                    builder.CreateBr(returnBB);
</span></span><span style="display:flex;"><span>                    br<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fixVariables(F);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> PreservedAnalyses<span style="color:#ec0000">::</span>none();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>已混淆IR(<code>-mllvm -passes=fla</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 noundef %argc, i8** noundef %argv) #0 {
entry:
  %cmp.reg2mem = alloca i1, align 1
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp ne i32 %0, 1
  store i1 %cmp, i1* %cmp.reg2mem, align 1
  %swVar.ptr = alloca i32, align 4
  store i32 99869029, i32* %swVar.ptr, align 4
  br label %dispatchBB

dispatchBB:                                       ; preds = %entry, %returnBB
  %swVar = load i32, i32* %swVar.ptr, align 4
  switch i32 %swVar, label %swDefault [
    i32 99869029, label %newBB
    i32 1698805515, label %if.then
    i32 -335309019, label %if.end
  ]

swDefault:                                        ; preds = %dispatchBB
  br label %returnBB

newBB:                                            ; preds = %dispatchBB
  %cmp.reload = load volatile i1, i1* %cmp.reg2mem, align 1
  %1 = select i1 %cmp.reload, i32 1698805515, i32 -335309019
  store i32 %1, i32* %swVar.ptr, align 4
  br label %returnBB

if.then:                                          ; preds = %dispatchBB
  %call = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))
  store i32 -335309019, i32* %swVar.ptr, align 4
  br label %returnBB

if.end:                                           ; preds = %dispatchBB
  ret i32 0

returnBB:                                         ; preds = %if.then, %newBB, %swDefault
  br label %dispatchBB
}
</code></pre><pre class="mermaid">flowchart LR
A([entry]) --> B([dispatchBB])
B([dispatchBB]) --> C([swDefault])
B([dispatchBB]) --> D([newBB])
B([dispatchBB]) --> E([if.then])
B([dispatchBB]) --> F([if.end])
C([swDefault]) --> G([returnBB])
D([newBB]) --> G([returnBB])
E([if.then]) --> G([returnBB])
F([if.end]) --> H([ret])
G([returnBB]) --> B([dispatchBB])
</pre>
<h3 id="hikari-boguscontrolflow模块分析">Hikari BogusControlFlow模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#5f5fff">void</span> <span style="color:#5f5fff">bogus</span>(Function <span style="color:#ec0000">&amp;</span>F) {
</span></span><span style="display:flex;"><span>    // For statistics and debug
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">int</span> NumBasicBlocks <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">bool</span> firstTime <span style="color:#ec0000">=</span> <span style="color:#ec0000">true</span>; // First time we do the loop in this function
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">bool</span> hasBeenModified <span style="color:#ec0000">=</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;opt&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Started on function &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> F.getName()
</span></span><span style="display:flex;"><span>                                  <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;opt&#34;</span>,
</span></span><span style="display:flex;"><span>                    errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Probability rate: &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> ObfProbRate <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (ObfProbRate <span style="color:#ec0000">&lt;</span> <span style="color:#008900">0</span> <span style="color:#ec0000">||</span> ObfProbRate <span style="color:#ec0000">&gt;</span> <span style="color:#008900">100</span>) {
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;opt&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                                 <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Incorrect value,&#34;</span>
</span></span><span style="display:flex;"><span>                                 <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34; probability rate set to default value: &#34;</span>
</span></span><span style="display:flex;"><span>                                 <span style="color:#ec0000">&lt;&lt;</span> defaultObfRate <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34; </span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      ObfProbRate <span style="color:#ec0000">=</span> defaultObfRate;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;opt&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                               <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: How many times: &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> ObfTimes <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (ObfTimes <span style="color:#ec0000">&lt;=</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;opt&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                                 <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Incorrect value,&#34;</span>
</span></span><span style="display:flex;"><span>                                 <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34; must be greater than 1. Set to default: &#34;</span>
</span></span><span style="display:flex;"><span>                                 <span style="color:#ec0000">&lt;&lt;</span> defaultObfTime <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34; </span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      ObfTimes <span style="color:#ec0000">=</span> defaultObfTime;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">int</span> NumObfTimes <span style="color:#ec0000">=</span> ObfTimes;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Real begining of the pass
</span></span><span style="display:flex;"><span>    // Loop for the number of time we run the pass on the function
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">do</span> {
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;cfg&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Function &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> F.getName()
</span></span><span style="display:flex;"><span>                                    <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;, before the pass:</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;cfg&#34;</span>, F.viewCFG());
</span></span><span style="display:flex;"><span>      // Put all the function&#39;s block in a list
</span></span><span style="display:flex;"><span>      std<span style="color:#ec0000">::</span>list<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;</span> basicBlocks;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (Function<span style="color:#ec0000">::</span>iterator i <span style="color:#ec0000">=</span> F.begin(); i <span style="color:#ec0000">!=</span> F.end(); <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>        BasicBlock <span style="color:#ec0000">*</span>BB <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;*</span>i;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>BB<span style="color:#ec0000">-&gt;</span>isEHPad() <span style="color:#ec0000">&amp;&amp;</span> <span style="color:#ec0000">!</span>BB<span style="color:#ec0000">-&gt;</span>isLandingPad()) {
</span></span><span style="display:flex;"><span>          basicBlocks.push_back(BB);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(
</span></span><span style="display:flex;"><span>          <span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Iterating on the Function&#39;s Basic Blocks</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">while</span> (<span style="color:#ec0000">!</span>basicBlocks.empty()) {
</span></span><span style="display:flex;"><span>        NumBasicBlocks<span style="color:#ec0000">++</span>;
</span></span><span style="display:flex;"><span>        // Basic Blocks&#39; selection
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> ((<span style="color:#5f5fff">int</span>)llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">100</span>) <span style="color:#ec0000">&lt;=</span> ObfProbRate) {
</span></span><span style="display:flex;"><span>          DEBUG_WITH_TYPE(<span style="color:#008900">&#34;opt&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Block &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> NumBasicBlocks
</span></span><span style="display:flex;"><span>                                        <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34; selected. </span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>          hasBeenModified <span style="color:#ec0000">=</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>          // Add bogus flow to the given Basic Block (see description)
</span></span><span style="display:flex;"><span>          BasicBlock <span style="color:#ec0000">*</span>basicBlock <span style="color:#ec0000">=</span> basicBlocks.front();
</span></span><span style="display:flex;"><span>          addBogusFlow(basicBlock, F);
</span></span><span style="display:flex;"><span>        } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>          DEBUG_WITH_TYPE(<span style="color:#008900">&#34;opt&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Block &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> NumBasicBlocks
</span></span><span style="display:flex;"><span>                                        <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34; not selected.</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        // remove the block from the list
</span></span><span style="display:flex;"><span>        basicBlocks.pop_front();
</span></span><span style="display:flex;"><span>      } // end of while(!basicBlocks.empty())
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>,
</span></span><span style="display:flex;"><span>                      errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: End of function &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> F.getName() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (hasBeenModified) { // if the function has been modified
</span></span><span style="display:flex;"><span>        DEBUG_WITH_TYPE(<span style="color:#008900">&#34;cfg&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Function &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> F.getName()
</span></span><span style="display:flex;"><span>                                      <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;, after the pass: </span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>        DEBUG_WITH_TYPE(<span style="color:#008900">&#34;cfg&#34;</span>, F.viewCFG());
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>        DEBUG_WITH_TYPE(<span style="color:#008900">&#34;cfg&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                                   <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Function&#39;s not been modified </span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      firstTime <span style="color:#ec0000">=</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#ec0000">while</span> (<span style="color:#ec0000">--</span>NumObfTimes <span style="color:#ec0000">&gt;</span> <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  /* addBogusFlow
</span></span><span style="display:flex;"><span>   *
</span></span><span style="display:flex;"><span>   * Add bogus flow to a given basic block, according to the header&#39;s
</span></span><span style="display:flex;"><span>   * description
</span></span><span style="display:flex;"><span>   */
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">virtual</span> <span style="color:#5f5fff">void</span> <span style="color:#5f5fff">addBogusFlow</span>(BasicBlock <span style="color:#ec0000">*</span>basicBlock, Function <span style="color:#ec0000">&amp;</span>F) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Split the block: first part with only the phi nodes and debug info and
</span></span><span style="display:flex;"><span>    // terminator
</span></span><span style="display:flex;"><span>    //                  created by splitBasicBlock. (-&gt; No instruction)
</span></span><span style="display:flex;"><span>    //                  Second part with every instructions from the original
</span></span><span style="display:flex;"><span>    //                  block
</span></span><span style="display:flex;"><span>    // We do this way, so we don&#39;t have to adjust all the phi nodes, metadatas
</span></span><span style="display:flex;"><span>    // and so on for the first block. We have to let the phi nodes in the first
</span></span><span style="display:flex;"><span>    // part, because they actually are updated in the second part according to
</span></span><span style="display:flex;"><span>    // them.
</span></span><span style="display:flex;"><span>    BasicBlock<span style="color:#ec0000">::</span>iterator i1 <span style="color:#ec0000">=</span> basicBlock<span style="color:#ec0000">-&gt;</span>begin();
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (basicBlock<span style="color:#ec0000">-&gt;</span>getFirstNonPHIOrDbgOrLifetime())
</span></span><span style="display:flex;"><span>      i1 <span style="color:#ec0000">=</span> (BasicBlock<span style="color:#ec0000">::</span>iterator)basicBlock<span style="color:#ec0000">-&gt;</span>getFirstNonPHIOrDbgOrLifetime();
</span></span><span style="display:flex;"><span>    Twine <span style="color:#ec0000">*</span>var;
</span></span><span style="display:flex;"><span>    var <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> Twine(<span style="color:#008900">&#34;originalBB&#34;</span>);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>originalBB <span style="color:#ec0000">=</span> basicBlock<span style="color:#ec0000">-&gt;</span>splitBasicBlock(i1, <span style="color:#ec0000">*</span>var);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                               <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: First and original basic blocks: ok</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Creating the altered basic block on which the first basicBlock will jump
</span></span><span style="display:flex;"><span>    Twine <span style="color:#ec0000">*</span>var3 <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> Twine(<span style="color:#008900">&#34;alteredBB&#34;</span>);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>alteredBB <span style="color:#ec0000">=</span> createAlteredBasicBlock(originalBB, <span style="color:#ec0000">*</span>var3, <span style="color:#ec0000">&amp;</span>F);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Altered basic block: ok</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Now that all the blocks are created,
</span></span><span style="display:flex;"><span>    // we modify the terminators to adjust the control flow.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    alteredBB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>    basicBlock<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Terminator removed from the altered&#34;</span>
</span></span><span style="display:flex;"><span>                                  <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34; and first basic blocks</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Preparing a condition..
</span></span><span style="display:flex;"><span>    // For now, the condition is an always true comparaison between 2 float
</span></span><span style="display:flex;"><span>    // This will be complicated after the pass (in doFinalization())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // We need to use ConstantInt instead of ConstantFP as ConstantFP results in strange dead-loop
</span></span><span style="display:flex;"><span>    // when injected into Xcode
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>LHS <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(F.getContext()), <span style="color:#008900">1</span>);
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>RHS <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(F.getContext()), <span style="color:#008900">1</span>);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Value LHS and RHS created</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // The always true condition. End of the first block
</span></span><span style="display:flex;"><span>    ICmpInst <span style="color:#ec0000">*</span>condition <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">new</span> ICmpInst(<span style="color:#ec0000">*</span>basicBlock, ICmpInst<span style="color:#ec0000">::</span>ICMP_EQ, LHS, RHS,<span style="color:#008900">&#34;BCFPlaceHolderPred&#34;</span>);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Always true condition created</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Jump to the original basic block if the condition is true or
</span></span><span style="display:flex;"><span>    // to the altered block if false.
</span></span><span style="display:flex;"><span>    BranchInst<span style="color:#ec0000">::</span>Create(originalBB, alteredBB, (Value <span style="color:#ec0000">*</span>)condition, basicBlock);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(
</span></span><span style="display:flex;"><span>        <span style="color:#008900">&#34;gen&#34;</span>,
</span></span><span style="display:flex;"><span>        errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Terminator instruction in first basic block: ok</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // The altered block loop back on the original one.
</span></span><span style="display:flex;"><span>    BranchInst<span style="color:#ec0000">::</span>Create(originalBB, alteredBB);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(
</span></span><span style="display:flex;"><span>        <span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Terminator instruction in altered block: ok</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // The end of the originalBB is modified to give the impression that
</span></span><span style="display:flex;"><span>    // sometimes it continues in the loop, and sometimes it return the desired
</span></span><span style="display:flex;"><span>    // value (of course it&#39;s always true, so it always use the original
</span></span><span style="display:flex;"><span>    // terminator..
</span></span><span style="display:flex;"><span>    //  but this will be obfuscated too;) )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // iterate on instruction just before the terminator of the originalBB
</span></span><span style="display:flex;"><span>    BasicBlock<span style="color:#ec0000">::</span>iterator i <span style="color:#ec0000">=</span> originalBB<span style="color:#ec0000">-&gt;</span>end();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Split at this point (we only want the terminator in the second part)
</span></span><span style="display:flex;"><span>    Twine <span style="color:#ec0000">*</span>var5 <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> Twine(<span style="color:#008900">&#34;originalBBpart2&#34;</span>);
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>originalBBpart2 <span style="color:#ec0000">=</span> originalBB<span style="color:#ec0000">-&gt;</span>splitBasicBlock(<span style="color:#ec0000">--</span>i, <span style="color:#ec0000">*</span>var5);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>,
</span></span><span style="display:flex;"><span>                    errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Terminator part of the original basic block&#34;</span>
</span></span><span style="display:flex;"><span>                           <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34; is isolated</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    // the first part go either on the return statement or on the begining
</span></span><span style="display:flex;"><span>    // of the altered block.. So we erase the terminator created when splitting.
</span></span><span style="display:flex;"><span>    originalBB<span style="color:#ec0000">-&gt;</span>getTerminator()<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>    // We add at the end a new always true condition
</span></span><span style="display:flex;"><span>    ICmpInst <span style="color:#ec0000">*</span>condition2 <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">new</span> ICmpInst(<span style="color:#ec0000">*</span>originalBB, CmpInst<span style="color:#ec0000">::</span>ICMP_EQ, LHS, RHS,<span style="color:#008900">&#34;BCFPlaceHolderPred&#34;</span>);
</span></span><span style="display:flex;"><span>    // BranchInst::Create(originalBBpart2, alteredBB, (Value
</span></span><span style="display:flex;"><span>    // *)condition2,originalBB);  Do random behavior to avoid pattern
</span></span><span style="display:flex;"><span>    // recognition This is achieved by jumping to a random BB
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">switch</span> (llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint16_t() <span style="color:#ec0000">%</span> <span style="color:#008900">2</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">case</span> <span style="color:#008900">0</span><span style="color:#ec0000">:</span> {
</span></span><span style="display:flex;"><span>      BranchInst<span style="color:#ec0000">::</span>Create(originalBBpart2, originalBB, condition2, originalBB);
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">case</span> <span style="color:#008900">1</span><span style="color:#ec0000">:</span> {
</span></span><span style="display:flex;"><span>      BranchInst<span style="color:#ec0000">::</span>Create(originalBBpart2, alteredBB, condition2, originalBB);
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">default</span><span style="color:#ec0000">:</span> {
</span></span><span style="display:flex;"><span>      BranchInst<span style="color:#ec0000">::</span>Create(originalBBpart2, originalBB, condition2, originalBB);
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                               <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Terminator original basic block: ok</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: End of addBogusFlow().</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  } // end of addBogusFlow()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  /* createAlteredBasicBlock
</span></span><span style="display:flex;"><span>   *
</span></span><span style="display:flex;"><span>   * This function return a basic block similar to a given one.
</span></span><span style="display:flex;"><span>   * It&#39;s inserted just after the given basic block.
</span></span><span style="display:flex;"><span>   * The instructions are similar but junk instructions are added between
</span></span><span style="display:flex;"><span>   * the cloned one. The cloned instructions&#39; phi nodes, metadatas, uses and
</span></span><span style="display:flex;"><span>   * debug locations are adjusted to fit in the cloned basic block and
</span></span><span style="display:flex;"><span>   * behave nicely.
</span></span><span style="display:flex;"><span>   */
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">virtual</span> BasicBlock <span style="color:#ec0000">*</span><span style="color:#5f5fff">createAlteredBasicBlock</span>(BasicBlock <span style="color:#ec0000">*</span>basicBlock,
</span></span><span style="display:flex;"><span>                                              <span style="color:#ec0000">const</span> Twine <span style="color:#ec0000">&amp;</span>Name <span style="color:#ec0000">=</span> <span style="color:#008900">&#34;gen&#34;</span>,
</span></span><span style="display:flex;"><span>                                              Function <span style="color:#ec0000">*</span>F <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>    // Useful to remap the informations concerning instructions.
</span></span><span style="display:flex;"><span>    ValueToValueMapTy VMap;
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>alteredBB <span style="color:#ec0000">=</span> llvm<span style="color:#ec0000">::</span>CloneBasicBlock(basicBlock, VMap, Name, F);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Original basic block cloned</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    // Remap operands.
</span></span><span style="display:flex;"><span>    BasicBlock<span style="color:#ec0000">::</span>iterator ji <span style="color:#ec0000">=</span> basicBlock<span style="color:#ec0000">-&gt;</span>begin();
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock<span style="color:#ec0000">::</span>iterator i <span style="color:#ec0000">=</span> alteredBB<span style="color:#ec0000">-&gt;</span>begin(), e <span style="color:#ec0000">=</span> alteredBB<span style="color:#ec0000">-&gt;</span>end();
</span></span><span style="display:flex;"><span>         i <span style="color:#ec0000">!=</span> e; <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>      // Loop over the operands of the instruction
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (User<span style="color:#ec0000">::</span>op_iterator opi <span style="color:#ec0000">=</span> i<span style="color:#ec0000">-&gt;</span>op_begin(), ope <span style="color:#ec0000">=</span> i<span style="color:#ec0000">-&gt;</span>op_end(); opi <span style="color:#ec0000">!=</span> ope;
</span></span><span style="display:flex;"><span>           <span style="color:#ec0000">++</span>opi) {
</span></span><span style="display:flex;"><span>        // get the value for the operand
</span></span><span style="display:flex;"><span>        Value <span style="color:#ec0000">*</span>v <span style="color:#ec0000">=</span> MapValue(<span style="color:#ec0000">*</span>opi, VMap, RF_None, <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (v <span style="color:#ec0000">!=</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">*</span>opi <span style="color:#ec0000">=</span> v;
</span></span><span style="display:flex;"><span>          DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>,
</span></span><span style="display:flex;"><span>                          errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Value&#39;s operand has been setted</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Operands remapped</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      // Remap phi nodes&#39; incoming blocks.
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (PHINode <span style="color:#ec0000">*</span>pn <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>PHINode<span style="color:#ec0000">&gt;</span>(i)) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> j <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>, e <span style="color:#ec0000">=</span> pn<span style="color:#ec0000">-&gt;</span>getNumIncomingValues(); j <span style="color:#ec0000">!=</span> e; <span style="color:#ec0000">++</span>j) {
</span></span><span style="display:flex;"><span>          Value <span style="color:#ec0000">*</span>v <span style="color:#ec0000">=</span> MapValue(pn<span style="color:#ec0000">-&gt;</span>getIncomingBlock(j), VMap, RF_None, <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (v <span style="color:#ec0000">!=</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>            pn<span style="color:#ec0000">-&gt;</span>setIncomingBlock(j, cast<span style="color:#ec0000">&lt;</span>BasicBlock<span style="color:#ec0000">&gt;</span>(v));
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: PHINodes remapped</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      // Remap attached metadata.
</span></span><span style="display:flex;"><span>      SmallVector<span style="color:#ec0000">&lt;</span>std<span style="color:#ec0000">::</span>pair<span style="color:#ec0000">&lt;</span><span style="color:#5f5fff">unsigned</span>, MDNode <span style="color:#ec0000">*&gt;</span>, <span style="color:#008900">4</span><span style="color:#ec0000">&gt;</span> MDs;
</span></span><span style="display:flex;"><span>      i<span style="color:#ec0000">-&gt;</span>getAllMetadata(MDs);
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Metadatas remapped</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      // important for compiling with DWARF, using option -g.
</span></span><span style="display:flex;"><span>      i<span style="color:#ec0000">-&gt;</span>setDebugLoc(ji<span style="color:#ec0000">-&gt;</span>getDebugLoc());
</span></span><span style="display:flex;"><span>      ji<span style="color:#ec0000">++</span>;
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                                 <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Debug information location setted</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } // The instructions&#39; informations are now all correct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>,
</span></span><span style="display:flex;"><span>                    errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: The cloned basic block is now correct</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(
</span></span><span style="display:flex;"><span>        <span style="color:#008900">&#34;gen&#34;</span>,
</span></span><span style="display:flex;"><span>        errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Starting to add junk code in the cloned bloc...</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // add random instruction in the middle of the bloc. This part can be
</span></span><span style="display:flex;"><span>    // improve
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock<span style="color:#ec0000">::</span>iterator i <span style="color:#ec0000">=</span> alteredBB<span style="color:#ec0000">-&gt;</span>begin(), e <span style="color:#ec0000">=</span> alteredBB<span style="color:#ec0000">-&gt;</span>end();
</span></span><span style="display:flex;"><span>         i <span style="color:#ec0000">!=</span> e; <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>      // in the case we find binary operator, we modify slightly this part by
</span></span><span style="display:flex;"><span>      // randomly insert some instructions
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (i<span style="color:#ec0000">-&gt;</span>isBinaryOp()) { // binary instructions
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">unsigned</span> opcode <span style="color:#ec0000">=</span> i<span style="color:#ec0000">-&gt;</span>getOpcode();
</span></span><span style="display:flex;"><span>        BinaryOperator <span style="color:#ec0000">*</span>op, <span style="color:#ec0000">*</span>op1 <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>        Twine <span style="color:#ec0000">*</span>var <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> Twine(<span style="color:#008900">&#34;_&#34;</span>);
</span></span><span style="display:flex;"><span>        // treat differently float or int
</span></span><span style="display:flex;"><span>        // Binary int
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>Add <span style="color:#ec0000">||</span> opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>Sub <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>            opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>Mul <span style="color:#ec0000">||</span> opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>UDiv <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>            opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>SDiv <span style="color:#ec0000">||</span> opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>URem <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>            opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>SRem <span style="color:#ec0000">||</span> opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>Shl <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>            opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>LShr <span style="color:#ec0000">||</span> opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>AShr <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>            opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>And <span style="color:#ec0000">||</span> opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>Or <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>            opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>Xor) {
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">int</span> random <span style="color:#ec0000">=</span> (<span style="color:#5f5fff">int</span>)llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">10</span>); random <span style="color:#ec0000">&lt;</span> <span style="color:#008900">10</span>;
</span></span><span style="display:flex;"><span>               <span style="color:#ec0000">++</span>random) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">switch</span> (llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">4</span>)) { // to improve
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">0</span><span style="color:#ec0000">:</span>                                    // do nothing
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">1</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              op <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>CreateNeg(i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>), <span style="color:#ec0000">*</span>var, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              op1 <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>Create(Instruction<span style="color:#ec0000">::</span>Add, op,
</span></span><span style="display:flex;"><span>                                           i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>), <span style="color:#008900">&#34;gen&#34;</span>, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">2</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              op1 <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>Create(Instruction<span style="color:#ec0000">::</span>Sub, i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>),
</span></span><span style="display:flex;"><span>                                           i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>), <span style="color:#ec0000">*</span>var, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              op <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>Create(Instruction<span style="color:#ec0000">::</span>Mul, op1,
</span></span><span style="display:flex;"><span>                                          i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>), <span style="color:#008900">&#34;gen&#34;</span>, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">3</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              op <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>Create(Instruction<span style="color:#ec0000">::</span>Shl, i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>),
</span></span><span style="display:flex;"><span>                                          i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>), <span style="color:#ec0000">*</span>var, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        // Binary float
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>FAdd <span style="color:#ec0000">||</span> opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>FSub <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>            opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>FMul <span style="color:#ec0000">||</span> opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>FDiv <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>            opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>FRem) {
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">int</span> random <span style="color:#ec0000">=</span> (<span style="color:#5f5fff">int</span>)llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">10</span>); random <span style="color:#ec0000">&lt;</span> <span style="color:#008900">10</span>;
</span></span><span style="display:flex;"><span>               <span style="color:#ec0000">++</span>random) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">switch</span> (llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">3</span>)) { // can be improved
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">0</span><span style="color:#ec0000">:</span>                                    // do nothing
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">1</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              op <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>CreateFNeg(i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>), <span style="color:#ec0000">*</span>var, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              op1 <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>Create(Instruction<span style="color:#ec0000">::</span>FAdd, op,
</span></span><span style="display:flex;"><span>                                           i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>), <span style="color:#008900">&#34;gen&#34;</span>, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">2</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              op <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>Create(Instruction<span style="color:#ec0000">::</span>FSub, i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>),
</span></span><span style="display:flex;"><span>                                          i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>), <span style="color:#ec0000">*</span>var, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              op1 <span style="color:#ec0000">=</span> BinaryOperator<span style="color:#ec0000">::</span>Create(Instruction<span style="color:#ec0000">::</span>FMul, op,
</span></span><span style="display:flex;"><span>                                           i<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">1</span>), <span style="color:#008900">&#34;gen&#34;</span>, <span style="color:#ec0000">&amp;*</span>i);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>ICmp) { // Condition (with int)
</span></span><span style="display:flex;"><span>          ICmpInst <span style="color:#ec0000">*</span>currentI <span style="color:#ec0000">=</span> (ICmpInst <span style="color:#ec0000">*</span>)(<span style="color:#ec0000">&amp;</span>i);
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">switch</span> (llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">3</span>)) { // must be improved
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> <span style="color:#008900">0</span><span style="color:#ec0000">:</span>                                    // do nothing
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> <span style="color:#008900">1</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>            currentI<span style="color:#ec0000">-&gt;</span>swapOperands();
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> <span style="color:#008900">2</span><span style="color:#ec0000">:</span> // randomly change the predicate
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">switch</span> (llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">10</span>)) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">0</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_EQ);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">1</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_NE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // not equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">2</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_UGT);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // unsigned greater than
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">3</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_UGE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // unsigned greater or equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">4</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_ULT);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // unsigned less than
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">5</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_ULE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // unsigned less or equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">6</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_SGT);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // signed greater than
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">7</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_SGE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // signed greater or equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">8</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_SLT);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // signed less than
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">9</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(ICmpInst<span style="color:#ec0000">::</span>ICMP_SLE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // signed less or equal
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>FCmp) { // Conditions (with float)
</span></span><span style="display:flex;"><span>          FCmpInst <span style="color:#ec0000">*</span>currentI <span style="color:#ec0000">=</span> (FCmpInst <span style="color:#ec0000">*</span>)(<span style="color:#ec0000">&amp;</span>i);
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">switch</span> (llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">3</span>)) { // must be improved
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> <span style="color:#008900">0</span><span style="color:#ec0000">:</span>                                    // do nothing
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> <span style="color:#008900">1</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>            currentI<span style="color:#ec0000">-&gt;</span>swapOperands();
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> <span style="color:#008900">2</span><span style="color:#ec0000">:</span> // randomly change the predicate
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">switch</span> (llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">10</span>)) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">0</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_OEQ);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // ordered and equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">1</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_ONE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // ordered and operands are unequal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">2</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_UGT);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // unordered or greater than
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">3</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_UGE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // unordered, or greater than, or equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">4</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_ULT);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // unordered or less than
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">5</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_ULE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // unordered, or less than, or equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">6</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_OGT);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // ordered and greater than
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">7</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_OGE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // ordered and greater than or equal
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">8</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_OLT);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // ordered and less than
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">case</span> <span style="color:#008900">9</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>              currentI<span style="color:#ec0000">-&gt;</span>setPredicate(FCmpInst<span style="color:#ec0000">::</span>FCMP_OLE);
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">break</span>; // ordered or less than, or equal
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    // Remove DIs from AlterBB
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>CallInst <span style="color:#ec0000">*&gt;</span> toRemove;
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>Constant<span style="color:#ec0000">*&gt;</span> DeadConstants;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (Instruction <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">I</span> : <span style="color:#ec0000">*</span>alteredBB) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (CallInst <span style="color:#ec0000">*</span>CI <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>CallInst<span style="color:#ec0000">&gt;</span>(<span style="color:#ec0000">&amp;</span>I)) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (CI<span style="color:#ec0000">-&gt;</span>getCalledFunction() <span style="color:#ec0000">!=</span> <span style="color:#ec0000">nullptr</span> <span style="color:#ec0000">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            CI<span style="color:#ec0000">-&gt;</span>getCalledFunction()<span style="color:#ec0000">-&gt;</span>getName().startswith(<span style="color:#008900">&#34;llvm.dbg&#34;</span>)) {
</span></span><span style="display:flex;"><span>          toRemove.push_back(CI);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    // Shamefully stolen from IPO/StripSymbols.cpp
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (CallInst <span style="color:#ec0000">*</span><span style="color:#ec0000">CI</span> : toRemove) {
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>Arg1 <span style="color:#ec0000">=</span> CI<span style="color:#ec0000">-&gt;</span>getArgOperand(<span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>Arg2 <span style="color:#ec0000">=</span> CI<span style="color:#ec0000">-&gt;</span>getArgOperand(<span style="color:#008900">1</span>);
</span></span><span style="display:flex;"><span>      assert(CI<span style="color:#ec0000">-&gt;</span>use_empty() <span style="color:#ec0000">&amp;&amp;</span> <span style="color:#008900">&#34;llvm.dbg intrinsic should have void result&#34;</span>);
</span></span><span style="display:flex;"><span>      CI<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (Arg1<span style="color:#ec0000">-&gt;</span>use_empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (Constant <span style="color:#ec0000">*</span>C <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>Constant<span style="color:#ec0000">&gt;</span>(Arg1)) {
</span></span><span style="display:flex;"><span>          DeadConstants.push_back(C);
</span></span><span style="display:flex;"><span>        } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>          RecursivelyDeleteTriviallyDeadInstructions(Arg1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (Arg2<span style="color:#ec0000">-&gt;</span>use_empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (Constant <span style="color:#ec0000">*</span>C <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>Constant<span style="color:#ec0000">&gt;</span>(Arg2)) {
</span></span><span style="display:flex;"><span>          DeadConstants.push_back(C);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">while</span> (<span style="color:#ec0000">!</span>DeadConstants.empty()) {
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>C <span style="color:#ec0000">=</span> DeadConstants.back();
</span></span><span style="display:flex;"><span>      DeadConstants.pop_back();
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (GlobalVariable <span style="color:#ec0000">*</span>GV <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(C)) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (GV<span style="color:#ec0000">-&gt;</span>hasLocalLinkage())
</span></span><span style="display:flex;"><span>          RemoveDeadConstant(GV);
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span>
</span></span><span style="display:flex;"><span>        RemoveDeadConstant(C);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> alteredBB;
</span></span><span style="display:flex;"><span>  } // end of createAlteredBasicBlock()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  /* doFinalization
</span></span><span style="display:flex;"><span>   *
</span></span><span style="display:flex;"><span>   * Overwrite FunctionPass method to apply the transformations to the whole
</span></span><span style="display:flex;"><span>   * module. This part obfuscate all the always true predicates of the module.
</span></span><span style="display:flex;"><span>   * More precisely, the condition which predicate is FCMP_TRUE.
</span></span><span style="display:flex;"><span>   * It also remove all the functions&#39; basic blocks&#39; and instructions&#39; names.
</span></span><span style="display:flex;"><span>   */
</span></span><span style="display:flex;"><span>  <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">doF</span>(Module <span style="color:#ec0000">&amp;</span>M) {
</span></span><span style="display:flex;"><span>    // In this part we extract all always-true predicate and replace them with
</span></span><span style="display:flex;"><span>    // opaque predicate: For this, we declare two global values: x and y, and
</span></span><span style="display:flex;"><span>    // replace the FCMP_TRUE predicate with (y &lt; 10 || x * (x + 1) % 2 == 0) A
</span></span><span style="display:flex;"><span>    // better way to obfuscate the predicates would be welcome. In the meantime
</span></span><span style="display:flex;"><span>    // we will erase the name of the basic blocks, the instructions and the
</span></span><span style="display:flex;"><span>    // functions.
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Starting doFinalization...</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span>Instruction <span style="color:#ec0000">*&gt;</span> toEdit, toDelete;
</span></span><span style="display:flex;"><span>    // BinaryOperator *op, *op1 = NULL;
</span></span><span style="display:flex;"><span>    // ICmpInst *condition, *condition2;
</span></span><span style="display:flex;"><span>    // Looking for the conditions and branches to transform
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (Module<span style="color:#ec0000">::</span>iterator mi <span style="color:#ec0000">=</span> M.begin(), me <span style="color:#ec0000">=</span> M.end(); mi <span style="color:#ec0000">!=</span> me; <span style="color:#ec0000">++</span>mi) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (Function<span style="color:#ec0000">::</span>iterator fi <span style="color:#ec0000">=</span> mi<span style="color:#ec0000">-&gt;</span>begin(), fe <span style="color:#ec0000">=</span> mi<span style="color:#ec0000">-&gt;</span>end(); fi <span style="color:#ec0000">!=</span> fe;
</span></span><span style="display:flex;"><span>           <span style="color:#ec0000">++</span>fi) {
</span></span><span style="display:flex;"><span>        // fi-&gt;setName(&#34;&#34;);
</span></span><span style="display:flex;"><span>        Instruction <span style="color:#ec0000">*</span>tbb <span style="color:#ec0000">=</span> fi<span style="color:#ec0000">-&gt;</span>getTerminator();
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (tbb<span style="color:#ec0000">-&gt;</span>getOpcode() <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>Br) {
</span></span><span style="display:flex;"><span>          BranchInst <span style="color:#ec0000">*</span>br <span style="color:#ec0000">=</span> (BranchInst <span style="color:#ec0000">*</span>)(tbb);
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (br<span style="color:#ec0000">-&gt;</span>isConditional()) {
</span></span><span style="display:flex;"><span>            ICmpInst <span style="color:#ec0000">*</span>cond <span style="color:#ec0000">=</span> (ICmpInst <span style="color:#ec0000">*</span>)br<span style="color:#ec0000">-&gt;</span>getCondition();
</span></span><span style="display:flex;"><span>            <span style="color:#5f5fff">unsigned</span> opcode <span style="color:#ec0000">=</span> cond<span style="color:#ec0000">-&gt;</span>getOpcode();
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (opcode <span style="color:#ec0000">==</span> Instruction<span style="color:#ec0000">::</span>ICmp) {
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">if</span> (cond<span style="color:#ec0000">-&gt;</span>getPredicate() <span style="color:#ec0000">==</span> ICmpInst<span style="color:#ec0000">::</span>ICMP_EQ <span style="color:#ec0000">&amp;&amp;</span> cond<span style="color:#ec0000">-&gt;</span>getName().startswith(<span style="color:#008900">&#34;BCFPlaceHolderPred&#34;</span>)) {
</span></span><span style="display:flex;"><span>                DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>,
</span></span><span style="display:flex;"><span>                                errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: an always true predicate !</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>                toDelete.push_back(cond); // The condition
</span></span><span style="display:flex;"><span>                toEdit.push_back(tbb);    // The branch using the condition
</span></span><span style="display:flex;"><span>              }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        /*
</span></span><span style="display:flex;"><span>        for (BasicBlock::iterator bi = fi-&gt;begin(), be = fi-&gt;end() ; bi != be;
</span></span><span style="display:flex;"><span>        ++bi){ bi-&gt;setName(&#34;&#34;); // setting the basic blocks&#39; names
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        */
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    // Replacing all the branches we found
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span>Instruction <span style="color:#ec0000">*&gt;::</span>iterator i <span style="color:#ec0000">=</span> toEdit.begin();
</span></span><span style="display:flex;"><span>         i <span style="color:#ec0000">!=</span> toEdit.end(); <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>      // Previously We Use LLVM EE To Calculate LHS and RHS
</span></span><span style="display:flex;"><span>      // Since IRBuilder&lt;&gt; uses ConstantFolding to fold constants.
</span></span><span style="display:flex;"><span>      // The return instruction is already returning constants
</span></span><span style="display:flex;"><span>      // The variable names below are the artifact from the Emulation Era
</span></span><span style="display:flex;"><span>      Type <span style="color:#ec0000">*</span>I32Ty <span style="color:#ec0000">=</span> Type<span style="color:#ec0000">::</span>getInt32Ty(M.getContext());
</span></span><span style="display:flex;"><span>      Module emuModule(<span style="color:#008900">&#34;HikariBCFEmulator&#34;</span>, M.getContext());
</span></span><span style="display:flex;"><span>      emuModule.setDataLayout(M.getDataLayout());
</span></span><span style="display:flex;"><span>      emuModule.setTargetTriple(M.getTargetTriple());
</span></span><span style="display:flex;"><span>      Function <span style="color:#ec0000">*</span>emuFunction <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          Function<span style="color:#ec0000">::</span>Create(FunctionType<span style="color:#ec0000">::</span>get(I32Ty, <span style="color:#ec0000">false</span>),
</span></span><span style="display:flex;"><span>                           GlobalValue<span style="color:#ec0000">::</span>LinkageTypes<span style="color:#ec0000">::</span>PrivateLinkage,
</span></span><span style="display:flex;"><span>                           <span style="color:#008900">&#34;BeginExecution&#34;</span>, <span style="color:#ec0000">&amp;</span>emuModule);
</span></span><span style="display:flex;"><span>      BasicBlock <span style="color:#ec0000">*</span>EntryBlock <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          BasicBlock<span style="color:#ec0000">::</span>Create(M.getContext(), <span style="color:#008900">&#34;&#34;</span>, emuFunction);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      Instruction <span style="color:#ec0000">*</span>tmp <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;*</span>((<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getFirstInsertionPt());
</span></span><span style="display:flex;"><span>      IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRBReal(tmp);
</span></span><span style="display:flex;"><span>      IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRBEmu(EntryBlock);
</span></span><span style="display:flex;"><span>      // First,Construct a real RHS that will be used in the actual condition
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>RealRHS <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(I32Ty, cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t());
</span></span><span style="display:flex;"><span>      // Prepare Initial LHS and RHS to bootstrap the emulator
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>LHSC <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(I32Ty, cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t());
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>RHSC <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(I32Ty, cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t());
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>LHSGV <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">new</span> GlobalVariable(M, Type<span style="color:#ec0000">::</span>getInt32Ty(M.getContext()), <span style="color:#ec0000">false</span>,
</span></span><span style="display:flex;"><span>                             GlobalValue<span style="color:#ec0000">::</span>PrivateLinkage, LHSC, <span style="color:#008900">&#34;LHSGV&#34;</span>);
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>RHSGV <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">new</span> GlobalVariable(M, Type<span style="color:#ec0000">::</span>getInt32Ty(M.getContext()), <span style="color:#ec0000">false</span>,
</span></span><span style="display:flex;"><span>                             GlobalValue<span style="color:#ec0000">::</span>PrivateLinkage, RHSC, <span style="color:#008900">&#34;RHSGV&#34;</span>);
</span></span><span style="display:flex;"><span>      LoadInst <span style="color:#ec0000">*</span>LHS <span style="color:#ec0000">=</span> IRBReal.CreateLoad(LHSGV, <span style="color:#008900">&#34;Initial LHS&#34;</span>);
</span></span><span style="display:flex;"><span>      LoadInst <span style="color:#ec0000">*</span>RHS <span style="color:#ec0000">=</span> IRBReal.CreateLoad(RHSGV, <span style="color:#008900">&#34;Initial LHS&#34;</span>);
</span></span><span style="display:flex;"><span>      // To Speed-Up Evaluation
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>emuLHS <span style="color:#ec0000">=</span> LHSC;
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>emuRHS <span style="color:#ec0000">=</span> RHSC;
</span></span><span style="display:flex;"><span>      Instruction<span style="color:#ec0000">::</span>BinaryOps initialOp <span style="color:#ec0000">=</span> ops[llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t() <span style="color:#ec0000">%</span>
</span></span><span style="display:flex;"><span>                                             (<span style="color:#ec0000">sizeof</span>(ops) <span style="color:#ec0000">/</span> <span style="color:#ec0000">sizeof</span>(ops[<span style="color:#008900">0</span>]))];
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>emuLast <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          IRBEmu.CreateBinOp(initialOp, emuLHS, emuRHS, <span style="color:#008900">&#34;EmuInitialCondition&#34;</span>);
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>Last <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>          IRBReal.CreateBinOp(initialOp, LHS, RHS, <span style="color:#008900">&#34;InitialCondition&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">int</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> ConditionExpressionComplexity; i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>        Constant <span style="color:#ec0000">*</span>newTmp <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(I32Ty, cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t());
</span></span><span style="display:flex;"><span>        Instruction<span style="color:#ec0000">::</span>BinaryOps initialOp <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>            ops[llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t() <span style="color:#ec0000">%</span>
</span></span><span style="display:flex;"><span>                (<span style="color:#ec0000">sizeof</span>(ops) <span style="color:#ec0000">/</span> <span style="color:#ec0000">sizeof</span>(ops[<span style="color:#008900">0</span>]))];
</span></span><span style="display:flex;"><span>        emuLast <span style="color:#ec0000">=</span> IRBEmu.CreateBinOp(initialOp, emuLast, newTmp,
</span></span><span style="display:flex;"><span>                                     <span style="color:#008900">&#34;EmuInitialCondition&#34;</span>);
</span></span><span style="display:flex;"><span>        Last <span style="color:#ec0000">=</span> IRBReal.CreateBinOp(initialOp, Last, newTmp, <span style="color:#008900">&#34;InitialCondition&#34;</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      // Randomly Generate Predicate
</span></span><span style="display:flex;"><span>      CmpInst<span style="color:#ec0000">::</span>Predicate pred <span style="color:#ec0000">=</span> preds[llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_uint32_t() <span style="color:#ec0000">%</span>
</span></span><span style="display:flex;"><span>                                      (<span style="color:#ec0000">sizeof</span>(preds) <span style="color:#ec0000">/</span> <span style="color:#ec0000">sizeof</span>(preds[<span style="color:#008900">0</span>]))];
</span></span><span style="display:flex;"><span>      Last <span style="color:#ec0000">=</span> IRBReal.CreateICmp(pred, Last, RealRHS);
</span></span><span style="display:flex;"><span>      emuLast <span style="color:#ec0000">=</span> IRBEmu.CreateICmp(pred, emuLast, RealRHS);
</span></span><span style="display:flex;"><span>      ReturnInst <span style="color:#ec0000">*</span>RI <span style="color:#ec0000">=</span> IRBEmu.CreateRet(emuLast);
</span></span><span style="display:flex;"><span>      ConstantInt <span style="color:#ec0000">*</span>emuCI <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(RI<span style="color:#ec0000">-&gt;</span>getReturnValue());
</span></span><span style="display:flex;"><span>      <span style="color:#5f5fff">uint64_t</span> emulateResult <span style="color:#ec0000">=</span> emuCI<span style="color:#ec0000">-&gt;</span>getZExtValue();
</span></span><span style="display:flex;"><span>      vector<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;</span> BBs; // Start To Prepare IndirectBranching
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (emulateResult <span style="color:#ec0000">==</span> <span style="color:#008900">1</span>) {
</span></span><span style="display:flex;"><span>        // Our ConstantExpr evaluates to true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        BranchInst<span style="color:#ec0000">::</span>Create(((BranchInst <span style="color:#ec0000">*</span>)<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>),
</span></span><span style="display:flex;"><span>                           ((BranchInst <span style="color:#ec0000">*</span>)<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">1</span>), (Value <span style="color:#ec0000">*</span>)Last,
</span></span><span style="display:flex;"><span>                           ((BranchInst <span style="color:#ec0000">*</span>)<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>getParent());
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>        // False, swap operands
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        BranchInst<span style="color:#ec0000">::</span>Create(((BranchInst <span style="color:#ec0000">*</span>)<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">1</span>),
</span></span><span style="display:flex;"><span>                           ((BranchInst <span style="color:#ec0000">*</span>)<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>), (Value <span style="color:#ec0000">*</span>)Last,
</span></span><span style="display:flex;"><span>                           ((BranchInst <span style="color:#ec0000">*</span>)<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>getParent());
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      EntryBlock<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>      emuFunction<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Erase branch instruction:&#34;</span>
</span></span><span style="display:flex;"><span>                                    <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#ec0000">*</span>((BranchInst <span style="color:#ec0000">*</span>)<span style="color:#ec0000">*</span>i) <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      (<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>eraseFromParent(); // erase the branch
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    // Erase all the associated conditions we found
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span>Instruction <span style="color:#ec0000">*&gt;::</span>iterator i <span style="color:#ec0000">=</span> toDelete.begin();
</span></span><span style="display:flex;"><span>         i <span style="color:#ec0000">!=</span> toDelete.end(); <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;gen&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Erase condition instruction:&#34;</span>
</span></span><span style="display:flex;"><span>                                    <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#ec0000">*</span>((Instruction <span style="color:#ec0000">*</span>)<span style="color:#ec0000">*</span>i) <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      (<span style="color:#ec0000">*</span>i)<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Only for debug
</span></span><span style="display:flex;"><span>    DEBUG_WITH_TYPE(<span style="color:#008900">&#34;cfg&#34;</span>, errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: End of the pass, here are the &#34;</span>
</span></span><span style="display:flex;"><span>                                     <span style="color:#008900">&#34;graphs after doFinalization</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (Module<span style="color:#ec0000">::</span>iterator mi <span style="color:#ec0000">=</span> M.begin(), me <span style="color:#ec0000">=</span> M.end(); mi <span style="color:#ec0000">!=</span> me; <span style="color:#ec0000">++</span>mi) {
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;cfg&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                                 <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;bcf: Function &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> mi<span style="color:#ec0000">-&gt;</span>getName() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>      DEBUG_WITH_TYPE(<span style="color:#008900">&#34;cfg&#34;</span>, mi<span style="color:#ec0000">-&gt;</span>viewCFG());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>  } // end of doFinalization
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  ret i32 0
}
</code></pre><p>已混淆IR(<code>-mllvm -enable-bcfobf</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@LHSGV = private global i32 -337248983
@RHSGV = private global i32 1241409517
@LHSGV.1 = private global i32 1605983733
@RHSGV.2 = private global i32 -1151943679

; Function Attrs: noinline norecurse optnone ssp uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %&#34;Initial LHS&#34; = load i32, i32* @LHSGV
  %&#34;Initial LHS2&#34; = load i32, i32* @RHSGV
  %InitialCondition = add i32 %&#34;Initial LHS&#34;, %&#34;Initial LHS2&#34;
  %InitialCondition3 = xor i32 %InitialCondition, 1256167145
  %InitialCondition4 = and i32 %InitialCondition3, 1503516098
  %InitialCondition5 = add i32 %InitialCondition4, -148188098
  %0 = icmp ult i32 %InitialCondition5, 695259654
  br i1 %0, label %originalBBalteredBB, label %originalBB

originalBB:                                       ; preds = %entry, %originalBBalteredBB
  %&#34;Initial LHS6&#34; = load i32, i32* @LHSGV.1
  %&#34;Initial LHS7&#34; = load i32, i32* @RHSGV.2
  %InitialCondition8 = add i32 %&#34;Initial LHS6&#34;, %&#34;Initial LHS7&#34;
  %InitialCondition9 = sub i32 %InitialCondition8, -1018173326
  %InitialCondition10 = or i32 %InitialCondition9, -63656773
  %InitialCondition11 = and i32 %InitialCondition10, 1604909974
  %1 = icmp ne i32 %InitialCondition11, 1137503584
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  br i1 %1, label %originalBBpart2, label %originalBBalteredBB

originalBBpart2:                                  ; preds = %originalBB
  ret i32 0

originalBBalteredBB:                              ; preds = %originalBB, %entry
  %retvalalteredBB = alloca i32, align 4
  %argc.addralteredBB = alloca i32, align 4
  %argv.addralteredBB = alloca i8**, align 8
  store i32 0, i32* %retvalalteredBB, align 4
  store i32 %argc, i32* %argc.addralteredBB, align 4
  store i8** %argv, i8*** %argv.addralteredBB, align 8
  %callalteredBB = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  br label %originalBB
}
</code></pre><pre class="mermaid">flowchart LR
A([entry]) --> B([originalBBalteredBB])
A([entry]) --> C([originalBB])
C([originalBB]) --> D([originalBBpart2])
C([originalBB]) --> B([originalBBalteredBB])
B([originalBBalteredBB]) --> C([originalBB])
D([originalBBpart2]) --> ret([ret])
</pre>
<p>  bcf是BasicBlock层的混淆，通过构造条件和分支使CF复杂化</p>
<h3 id="pluto-mbaobfuscation模块分析">Pluto MbaObfuscation模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PreservedAnalyses Pluto<span style="color:#ec0000">::</span>MbaObfuscation<span style="color:#ec0000">::</span>run(Function <span style="color:#ec0000">&amp;</span>F, FunctionAnalysisManager <span style="color:#ec0000">&amp;</span>AM) {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">BB</span> : F) {
</span></span><span style="display:flex;"><span>        std<span style="color:#ec0000">::</span>vector<span style="color:#ec0000">&lt;</span>Instruction <span style="color:#ec0000">*&gt;</span> origInst;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (Instruction <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">I</span> : BB) {
</span></span><span style="display:flex;"><span>            origInst.push_back(<span style="color:#ec0000">&amp;</span>I);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">for</span> (Instruction <span style="color:#ec0000">*</span><span style="color:#ec0000">I</span> : origInst) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (isa<span style="color:#ec0000">&lt;</span>BinaryOperator<span style="color:#ec0000">&gt;</span>(I)) {
</span></span><span style="display:flex;"><span>                BinaryOperator <span style="color:#ec0000">*</span>BI <span style="color:#ec0000">=</span> cast<span style="color:#ec0000">&lt;</span>BinaryOperator<span style="color:#ec0000">&gt;</span>(I);
</span></span><span style="display:flex;"><span>                <span style="color:#ec0000">if</span> (BI<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>)<span style="color:#ec0000">-&gt;</span>getType()<span style="color:#ec0000">-&gt;</span>isIntegerTy()) {
</span></span><span style="display:flex;"><span>                    // Do not support 128-bit integers now
</span></span><span style="display:flex;"><span>                    <span style="color:#ec0000">if</span> (BI<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>)<span style="color:#ec0000">-&gt;</span>getType()<span style="color:#ec0000">-&gt;</span>getIntegerBitWidth() <span style="color:#ec0000">&gt;</span> <span style="color:#008900">64</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    substitute(BI);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">int</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> I<span style="color:#ec0000">-&gt;</span>getNumOperands(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ec0000">if</span> (I<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>)<span style="color:#ec0000">-&gt;</span>getType()<span style="color:#ec0000">-&gt;</span>isIntegerTy()) {
</span></span><span style="display:flex;"><span>                        // error occurs for unknown reasons
</span></span><span style="display:flex;"><span>                        // if(isa&lt;StoreInst&gt;(I) || isa&lt;CmpInst&gt;(I) || isa&lt;CallInst&gt;(I)){
</span></span><span style="display:flex;"><span>                        <span style="color:#ec0000">if</span> (isa<span style="color:#ec0000">&lt;</span>StoreInst<span style="color:#ec0000">&gt;</span>(I) <span style="color:#ec0000">||</span> isa<span style="color:#ec0000">&lt;</span>CmpInst<span style="color:#ec0000">&gt;</span>(I)) {
</span></span><span style="display:flex;"><span>                            substituteConstant(I, i);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    PreservedAnalyses PA;
</span></span><span style="display:flex;"><span>    PA.preserveSet<span style="color:#ec0000">&lt;</span>CFGAnalyses<span style="color:#ec0000">&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> PA;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> Pluto<span style="color:#ec0000">::</span>MbaObfuscation<span style="color:#ec0000">::</span>substituteConstant(Instruction <span style="color:#ec0000">*</span>I, <span style="color:#5f5fff">int</span> i) {
</span></span><span style="display:flex;"><span>    ConstantInt <span style="color:#ec0000">*</span>val <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantInt<span style="color:#ec0000">&gt;</span>(I<span style="color:#ec0000">-&gt;</span>getOperand(i));
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (val <span style="color:#ec0000">&amp;&amp;</span> val<span style="color:#ec0000">-&gt;</span>getBitWidth() <span style="color:#ec0000">&lt;=</span> <span style="color:#008900">64</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#5f5fff">int64_t</span> <span style="color:#ec0000">*</span>coeffs <span style="color:#ec0000">=</span> generateLinearMBA(NUM_COEFFS);
</span></span><span style="display:flex;"><span>        coeffs[<span style="color:#008900">14</span>] <span style="color:#ec0000">-=</span> val<span style="color:#ec0000">-&gt;</span>getValue().getZExtValue();
</span></span><span style="display:flex;"><span>        Value <span style="color:#ec0000">*</span>mbaExpr <span style="color:#ec0000">=</span> insertLinearMBA(coeffs, I);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">delete</span>[] coeffs;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (val<span style="color:#ec0000">-&gt;</span>getBitWidth() <span style="color:#ec0000">&lt;=</span> <span style="color:#008900">32</span>) {
</span></span><span style="display:flex;"><span>            mbaExpr <span style="color:#ec0000">=</span> insertPolynomialMBA(mbaExpr, I);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        I<span style="color:#ec0000">-&gt;</span>setOperand(i, mbaExpr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5f5fff">void</span> Pluto<span style="color:#ec0000">::</span>MbaObfuscation<span style="color:#ec0000">::</span>substitute(BinaryOperator <span style="color:#ec0000">*</span>BI) {
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>mbaExpr <span style="color:#ec0000">=</span> <span style="color:#ec0000">nullptr</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">switch</span> (BI<span style="color:#ec0000">-&gt;</span>getOpcode()) {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">Add</span>:
</span></span><span style="display:flex;"><span>        mbaExpr <span style="color:#ec0000">=</span> substituteAdd(BI);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">Sub</span>:
</span></span><span style="display:flex;"><span>        mbaExpr <span style="color:#ec0000">=</span> substituteSub(BI);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">And</span>:
</span></span><span style="display:flex;"><span>        mbaExpr <span style="color:#ec0000">=</span> substituteAnd(BI);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">Or</span>:
</span></span><span style="display:flex;"><span>        mbaExpr <span style="color:#ec0000">=</span> substituteOr(BI);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">Xor</span>:
</span></span><span style="display:flex;"><span>        mbaExpr <span style="color:#ec0000">=</span> substituteXor(BI);
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">default</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (mbaExpr) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (BI<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>)<span style="color:#ec0000">-&gt;</span>getType()<span style="color:#ec0000">-&gt;</span>getIntegerBitWidth() <span style="color:#ec0000">&lt;=</span> <span style="color:#008900">32</span>) {
</span></span><span style="display:flex;"><span>            mbaExpr <span style="color:#ec0000">=</span> insertPolynomialMBA(mbaExpr, BI);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        BI<span style="color:#ec0000">-&gt;</span>replaceAllUsesWith(mbaExpr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 noundef %0, i8** noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i8**, align 8
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
  %6 = load i32, i32* %4, align 4
  %7 = icmp eq i32 %6, 1
  br i1 %7, label %8, label %10

8:                                                ; preds = %2
  %9 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))
  br label %10

10:                                               ; preds = %8, %2
  ret i32 0
}
</code></pre><p>已混淆IR(<code>-mllvm -passes=mba</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@.str = private unnamed_addr constant [6 x i8] c&#34;hello\00&#34;, align 1
@x = private global i32 633921516
@y = private global i32 -929520819
@x.1 = private global i32 -269327150
@y.2 = private global i32 -1823721797

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @main(i32 noundef %0, i8** noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i8**, align 8
  %6 = load i32, i32* @x, align 4
  %7 = load i32, i32* @y, align 4
  store i32 0, i32* %3, align 4
  store i32 %0, i32* %4, align 4
  store i8** %1, i8*** %5, align 8
  %8 = load i32, i32* %4, align 4
  %9 = load i32, i32* @x.1, align 4
  %10 = load i32, i32* @y.2, align 4
  %11 = xor i32 %10, -1
  %12 = and i32 %9, %11
  %13 = mul i32 -1, %12
  %14 = add i32 0, %13
  %15 = xor i32 %9, %10
  %16 = xor i32 %15, -1
  %17 = mul i32 -1, %16
  %18 = add i32 %14, %17
  %19 = xor i32 %10, -1
  %20 = or i32 %9, %19
  %21 = mul i32 1, %20
  %22 = add i32 %18, %21
  %23 = add i32 %22, 1
  %24 = mul i32 -2064751721, %23
  %25 = add i32 %24, -1348253517
  %26 = mul i32 43142183, %25
  %27 = add i32 %26, -394999621
  %28 = icmp eq i32 %8, %27
  br i1 %28, label %29, label %31

29:                                               ; preds = %2
  %30 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))
  br label %31

31:                                               ; preds = %29, %2
  ret i32 0
}
</code></pre><h2 id="函数级别的混淆">函数级别的混淆</h2>
<h3 id="hikari-functioncallobfuscate模块分析">Hikari FunctionCallObfuscate模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#ec0000">virtual</span> <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">doInitialization</span>(Module <span style="color:#ec0000">&amp;</span>M) <span style="color:#ec0000">override</span> {
</span></span><span style="display:flex;"><span>    // Basic Defs
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (SymbolConfigPath <span style="color:#ec0000">==</span> <span style="color:#008900">&#34;+-x/&#34;</span>) {
</span></span><span style="display:flex;"><span>      SmallString<span style="color:#ec0000">&lt;</span><span style="color:#008900">32</span><span style="color:#ec0000">&gt;</span> Path;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (sys<span style="color:#ec0000">::</span>path<span style="color:#ec0000">::</span>home_directory(Path)) { // Stolen from LineEditor.cpp
</span></span><span style="display:flex;"><span>        sys<span style="color:#ec0000">::</span>path<span style="color:#ec0000">::</span>append(Path, <span style="color:#008900">&#34;Hikari&#34;</span>, <span style="color:#008900">&#34;SymbolConfig.json&#34;</span>);
</span></span><span style="display:flex;"><span>        SymbolConfigPath <span style="color:#ec0000">=</span> Path.str();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ifstream infile(SymbolConfigPath);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (infile.good()) {
</span></span><span style="display:flex;"><span>      errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;Loading Symbol Configuration From:&#34;</span> <span style="color:#ec0000">&lt;&lt;</span> SymbolConfigPath
</span></span><span style="display:flex;"><span>             <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>      infile <span style="color:#ec0000">&gt;&gt;</span> <span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;</span>Configuration;
</span></span><span style="display:flex;"><span>    } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>      errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;Failed To Loading Symbol Configuration From:&#34;</span>
</span></span><span style="display:flex;"><span>             <span style="color:#ec0000">&lt;&lt;</span> SymbolConfigPath <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Triple tri(M.getTargetTriple());
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (tri.getVendor() <span style="color:#ec0000">!=</span> Triple<span style="color:#ec0000">::</span>VendorType<span style="color:#ec0000">::</span>Apple) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Type <span style="color:#ec0000">*</span>Int64Ty <span style="color:#ec0000">=</span> Type<span style="color:#ec0000">::</span>getInt64Ty(M.getContext());
</span></span><span style="display:flex;"><span>    Type <span style="color:#ec0000">*</span>Int32Ty <span style="color:#ec0000">=</span> Type<span style="color:#ec0000">::</span>getInt32Ty(M.getContext());
</span></span><span style="display:flex;"><span>    Type <span style="color:#ec0000">*</span>Int8PtrTy <span style="color:#ec0000">=</span> Type<span style="color:#ec0000">::</span>getInt8PtrTy(M.getContext());
</span></span><span style="display:flex;"><span>    Type <span style="color:#ec0000">*</span>Int8Ty <span style="color:#ec0000">=</span> Type<span style="color:#ec0000">::</span>getInt8Ty(M.getContext());
</span></span><span style="display:flex;"><span>    // Generic ObjC Runtime Declarations
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>IMPType <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(Int8PtrTy, {Int8PtrTy, Int8PtrTy}, <span style="color:#ec0000">true</span>);
</span></span><span style="display:flex;"><span>    PointerType <span style="color:#ec0000">*</span>IMPPointerType <span style="color:#ec0000">=</span> PointerType<span style="color:#ec0000">::</span>get(IMPType, <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span> classReplaceMethodTypeArgs;
</span></span><span style="display:flex;"><span>    classReplaceMethodTypeArgs.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    classReplaceMethodTypeArgs.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    classReplaceMethodTypeArgs.push_back(IMPPointerType);
</span></span><span style="display:flex;"><span>    classReplaceMethodTypeArgs.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>class_replaceMethod_type <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(IMPPointerType, classReplaceMethodTypeArgs, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    M.getOrInsertFunction(<span style="color:#008900">&#34;class_replaceMethod&#34;</span>, class_replaceMethod_type);
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>sel_registerName_type <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(Int8PtrTy, {Int8PtrTy}, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    M.getOrInsertFunction(<span style="color:#008900">&#34;sel_registerName&#34;</span>, sel_registerName_type);
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>objc_getClass_type <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(Int8PtrTy, {Int8PtrTy}, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    M.getOrInsertFunction(<span style="color:#008900">&#34;objc_getClass&#34;</span>, objc_getClass_type);
</span></span><span style="display:flex;"><span>    M.getOrInsertFunction(<span style="color:#008900">&#34;objc_getMetaClass&#34;</span>, objc_getClass_type);
</span></span><span style="display:flex;"><span>    StructType <span style="color:#ec0000">*</span>objc_property_attribute_t_type <span style="color:#ec0000">=</span> <span style="color:#ec0000">reinterpret_cast</span><span style="color:#ec0000">&lt;</span>StructType <span style="color:#ec0000">*&gt;</span>(
</span></span><span style="display:flex;"><span>        M.getTypeByName(<span style="color:#008900">&#34;struct.objc_property_attribute_t&#34;</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (objc_property_attribute_t_type <span style="color:#ec0000">==</span> <span style="color:#ec0000">NULL</span>) {
</span></span><span style="display:flex;"><span>      vector<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span> types;
</span></span><span style="display:flex;"><span>      types.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>      types.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>      objc_property_attribute_t_type <span style="color:#ec0000">=</span> StructType<span style="color:#ec0000">::</span>create(
</span></span><span style="display:flex;"><span>          ArrayRef<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span>(types), <span style="color:#008900">&#34;struct.objc_property_attribute_t&#34;</span>);
</span></span><span style="display:flex;"><span>      M.getOrInsertGlobal(<span style="color:#008900">&#34;struct.objc_property_attribute_t&#34;</span>,
</span></span><span style="display:flex;"><span>                          objc_property_attribute_t_type);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span> allocaClsTypeVector;
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span> addIvarTypeVector;
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span> addPropTypeVector;
</span></span><span style="display:flex;"><span>    allocaClsTypeVector.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    allocaClsTypeVector.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    addIvarTypeVector.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    addIvarTypeVector.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    addPropTypeVector.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    addPropTypeVector.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    addPropTypeVector.push_back(objc_property_attribute_t_type<span style="color:#ec0000">-&gt;</span>getPointerTo());
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (tri.isArch64Bit()) {
</span></span><span style="display:flex;"><span>      // We are 64Bit Device
</span></span><span style="display:flex;"><span>      allocaClsTypeVector.push_back(Int64Ty);
</span></span><span style="display:flex;"><span>      addIvarTypeVector.push_back(Int64Ty);
</span></span><span style="display:flex;"><span>      addPropTypeVector.push_back(Int64Ty);
</span></span><span style="display:flex;"><span>    } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>      // Not 64Bit.However we are still on apple platform.So We are
</span></span><span style="display:flex;"><span>      // ARMV7/ARMV7S/i386
</span></span><span style="display:flex;"><span>      // PowerPC is ignored, feel free to open a PR if you want to
</span></span><span style="display:flex;"><span>      allocaClsTypeVector.push_back(Int32Ty);
</span></span><span style="display:flex;"><span>      addIvarTypeVector.push_back(Int32Ty);
</span></span><span style="display:flex;"><span>      addPropTypeVector.push_back(Int32Ty);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    addIvarTypeVector.push_back(Int8Ty);
</span></span><span style="display:flex;"><span>    addIvarTypeVector.push_back(Int8PtrTy);
</span></span><span style="display:flex;"><span>    // Types Collected. Now Inject Functions
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>addIvarType <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(Int8Ty, ArrayRef<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span>(addIvarTypeVector), <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    M.getOrInsertFunction(<span style="color:#008900">&#34;class_addIvar&#34;</span>, addIvarType);
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>addPropType <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(Int8Ty, ArrayRef<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span>(addPropTypeVector), <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    M.getOrInsertFunction(<span style="color:#008900">&#34;class_addProperty&#34;</span>, addPropType);
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>class_getName_Type <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(Int8PtrTy, {Int8PtrTy}, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    M.getOrInsertFunction(<span style="color:#008900">&#34;class_getName&#34;</span>, class_getName_Type);
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>objc_getMetaClass_Type <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(Int8PtrTy, {Int8PtrTy}, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    M.getOrInsertFunction(<span style="color:#008900">&#34;objc_getMetaClass&#34;</span>, objc_getMetaClass_Type);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#5f5fff">void</span> <span style="color:#5f5fff">HandleObjC</span>(Module <span style="color:#ec0000">&amp;</span>M) {
</span></span><span style="display:flex;"><span>    // Iterate all CLASSREF uses and replace with objc_getClass() call
</span></span><span style="display:flex;"><span>    // Strings are encrypted in other passes
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> G <span style="color:#ec0000">=</span> M.global_begin(); G <span style="color:#ec0000">!=</span> M.global_end(); G<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">&amp;</span>GV <span style="color:#ec0000">=</span> <span style="color:#ec0000">*</span>G;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (GV.getName().str().find(<span style="color:#008900">&#34;OBJC_CLASSLIST_REFERENCES&#34;</span>) <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (GV.hasInitializer()) {
</span></span><span style="display:flex;"><span>          string className <span style="color:#ec0000">=</span> GV.getInitializer()<span style="color:#ec0000">-&gt;</span>getName();
</span></span><span style="display:flex;"><span>          className.replace(className.find(<span style="color:#008900">&#34;OBJC_CLASS_$_&#34;</span>),
</span></span><span style="display:flex;"><span>                            strlen(<span style="color:#008900">&#34;OBJC_CLASS_$_&#34;</span>), <span style="color:#008900">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> U <span style="color:#ec0000">=</span> GV.user_begin(); U <span style="color:#ec0000">!=</span> GV.user_end(); U<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (Instruction <span style="color:#ec0000">*</span>I <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>Instruction<span style="color:#ec0000">&gt;</span>(<span style="color:#ec0000">*</span>U)) {
</span></span><span style="display:flex;"><span>              IRBuilder<span style="color:#ec0000">&lt;&gt;</span> builder(I);
</span></span><span style="display:flex;"><span>              Function <span style="color:#ec0000">*</span>objc_getClass_Func <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                  cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(M.getFunction(<span style="color:#008900">&#34;objc_getClass&#34;</span>));
</span></span><span style="display:flex;"><span>              Value <span style="color:#ec0000">*</span>newClassName <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                  builder.CreateGlobalStringPtr(StringRef(className));
</span></span><span style="display:flex;"><span>              CallInst <span style="color:#ec0000">*</span>CI <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                  builder.CreateCall(objc_getClass_Func, {newClassName});
</span></span><span style="display:flex;"><span>              // We need to bitcast it back to avoid IRVerifier
</span></span><span style="display:flex;"><span>              Value <span style="color:#ec0000">*</span>BCI <span style="color:#ec0000">=</span> builder.CreateBitCast(CI, I<span style="color:#ec0000">-&gt;</span>getType());
</span></span><span style="display:flex;"><span>              I<span style="color:#ec0000">-&gt;</span>replaceAllUsesWith(BCI);
</span></span><span style="display:flex;"><span>              I<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          GV.removeDeadConstantUsers();
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (GV.getNumUses() <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>            GV.dropAllReferences();
</span></span><span style="display:flex;"><span>            GV.eraseFromParent();
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      // Selector Convert
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">else</span> <span style="color:#ec0000">if</span> (GV.getName().str().find(<span style="color:#008900">&#34;OBJC_SELECTOR_REFERENCES&#34;</span>) <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (GV.hasInitializer()) {
</span></span><span style="display:flex;"><span>          ConstantExpr <span style="color:#ec0000">*</span>CE <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>ConstantExpr<span style="color:#ec0000">&gt;</span>(GV.getInitializer());
</span></span><span style="display:flex;"><span>          Constant <span style="color:#ec0000">*</span>C <span style="color:#ec0000">=</span> CE<span style="color:#ec0000">-&gt;</span>getOperand(<span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>          GlobalVariable <span style="color:#ec0000">*</span>SELNameGV <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>GlobalVariable<span style="color:#ec0000">&gt;</span>(C);
</span></span><span style="display:flex;"><span>          ConstantDataArray <span style="color:#ec0000">*</span>CDA <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>              dyn_cast<span style="color:#ec0000">&lt;</span>ConstantDataArray<span style="color:#ec0000">&gt;</span>(SELNameGV<span style="color:#ec0000">-&gt;</span>getInitializer());
</span></span><span style="display:flex;"><span>          StringRef SELName <span style="color:#ec0000">=</span> CDA<span style="color:#ec0000">-&gt;</span>getAsString(); // This is REAL Selector Name
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> U <span style="color:#ec0000">=</span> GV.user_begin(); U <span style="color:#ec0000">!=</span> GV.user_end(); U<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">if</span> (Instruction <span style="color:#ec0000">*</span>I <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>Instruction<span style="color:#ec0000">&gt;</span>(<span style="color:#ec0000">*</span>U)) {
</span></span><span style="display:flex;"><span>              IRBuilder<span style="color:#ec0000">&lt;&gt;</span> builder(I);
</span></span><span style="display:flex;"><span>              Function <span style="color:#ec0000">*</span>sel_registerName_Func <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                  cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(M.getFunction(<span style="color:#008900">&#34;sel_registerName&#34;</span>));
</span></span><span style="display:flex;"><span>              Value <span style="color:#ec0000">*</span>newGlobalSELName <span style="color:#ec0000">=</span> builder.CreateGlobalStringPtr(SELName);
</span></span><span style="display:flex;"><span>              CallInst <span style="color:#ec0000">*</span>CI <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                  builder.CreateCall(sel_registerName_Func, {newGlobalSELName});
</span></span><span style="display:flex;"><span>              // We need to bitcast it back to avoid IRVerifier
</span></span><span style="display:flex;"><span>              Value <span style="color:#ec0000">*</span>BCI <span style="color:#ec0000">=</span> builder.CreateBitCast(CI, I<span style="color:#ec0000">-&gt;</span>getType());
</span></span><span style="display:flex;"><span>              I<span style="color:#ec0000">-&gt;</span>replaceAllUsesWith(BCI);
</span></span><span style="display:flex;"><span>              I<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          GV.removeDeadConstantUsers();
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (GV.getNumUses() <span style="color:#ec0000">==</span> <span style="color:#008900">0</span>) {
</span></span><span style="display:flex;"><span>            GV.dropAllReferences();
</span></span><span style="display:flex;"><span>            GV.eraseFromParent();
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">virtual</span> <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">runOnFunction</span>(Function <span style="color:#ec0000">&amp;</span>F) <span style="color:#ec0000">override</span> {
</span></span><span style="display:flex;"><span>    // Construct Function Prototypes
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (toObfuscate(flag, <span style="color:#ec0000">&amp;</span>F, <span style="color:#008900">&#34;fco&#34;</span>) <span style="color:#ec0000">==</span> <span style="color:#ec0000">false</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Triple Tri(F.getParent()<span style="color:#ec0000">-&gt;</span>getTargetTriple());
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>Tri.isAndroid() <span style="color:#ec0000">&amp;&amp;</span> <span style="color:#ec0000">!</span>Tri.isOSDarwin()) {
</span></span><span style="display:flex;"><span>      errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;Unsupported Target Triple:&#34;</span><span style="color:#ec0000">&lt;&lt;</span> F.getParent()<span style="color:#ec0000">-&gt;</span>getTargetTriple() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;Running FunctionCallObfuscate On &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> F.getName() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>    Module <span style="color:#ec0000">*</span>M <span style="color:#ec0000">=</span> F.getParent();
</span></span><span style="display:flex;"><span>    FixFunctionConstantExpr(<span style="color:#ec0000">&amp;</span>F);
</span></span><span style="display:flex;"><span>    HandleObjC(<span style="color:#ec0000">*</span>M);
</span></span><span style="display:flex;"><span>    Type <span style="color:#ec0000">*</span>Int32Ty <span style="color:#ec0000">=</span> Type<span style="color:#ec0000">::</span>getInt32Ty(M<span style="color:#ec0000">-&gt;</span>getContext());
</span></span><span style="display:flex;"><span>    Type <span style="color:#ec0000">*</span>Int8PtrTy <span style="color:#ec0000">=</span> Type<span style="color:#ec0000">::</span>getInt8PtrTy(M<span style="color:#ec0000">-&gt;</span>getContext());
</span></span><span style="display:flex;"><span>    // ObjC Runtime Declarations
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>dlopen_type <span style="color:#ec0000">=</span> FunctionType<span style="color:#ec0000">::</span>get(
</span></span><span style="display:flex;"><span>        Int8PtrTy, {Int8PtrTy, Int32Ty},
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">false</span>); // int has a length of 32 on both 32/64bit platform
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>dlsym_type <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(Int8PtrTy, {Int8PtrTy, Int8PtrTy}, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    Function <span style="color:#ec0000">*</span>dlopen_decl <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(M<span style="color:#ec0000">-&gt;</span>getOrInsertFunction(<span style="color:#008900">&#34;dlopen&#34;</span>, dlopen_type));
</span></span><span style="display:flex;"><span>    Function <span style="color:#ec0000">*</span>dlsym_decl <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(M<span style="color:#ec0000">-&gt;</span>getOrInsertFunction(<span style="color:#008900">&#34;dlsym&#34;</span>, dlsym_type));
</span></span><span style="display:flex;"><span>    // Begin Iteration
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BasicBlock <span style="color:#ec0000">&amp;</span><span style="color:#ec0000">BB</span> : F) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> I <span style="color:#ec0000">=</span> BB.getFirstInsertionPt(), end <span style="color:#ec0000">=</span> BB.end(); I <span style="color:#ec0000">!=</span> end; <span style="color:#ec0000">++</span>I) {
</span></span><span style="display:flex;"><span>        Instruction <span style="color:#ec0000">&amp;</span>Inst <span style="color:#ec0000">=</span> <span style="color:#ec0000">*</span>I;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (isa<span style="color:#ec0000">&lt;</span>CallInst<span style="color:#ec0000">&gt;</span>(<span style="color:#ec0000">&amp;</span>Inst) <span style="color:#ec0000">||</span> isa<span style="color:#ec0000">&lt;</span>InvokeInst<span style="color:#ec0000">&gt;</span>(<span style="color:#ec0000">&amp;</span>Inst)) {
</span></span><span style="display:flex;"><span>          CallSite CS(<span style="color:#ec0000">&amp;</span>Inst);
</span></span><span style="display:flex;"><span>          Function <span style="color:#ec0000">*</span>calledFunction <span style="color:#ec0000">=</span> CS.getCalledFunction();
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (calledFunction <span style="color:#ec0000">==</span> <span style="color:#ec0000">NULL</span>) {
</span></span><span style="display:flex;"><span>            /*
</span></span><span style="display:flex;"><span>              Note:
</span></span><span style="display:flex;"><span>              For Indirect Calls:
</span></span><span style="display:flex;"><span>                CalledFunction is NULL and calledValue is usually a bitcasted
</span></span><span style="display:flex;"><span>              function pointer. We&#39;ll need to strip out the hiccups and obtain
</span></span><span style="display:flex;"><span>              the called Function* from there
</span></span><span style="display:flex;"><span>            */
</span></span><span style="display:flex;"><span>            calledFunction <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                dyn_cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(CS.getCalledValue()<span style="color:#ec0000">-&gt;</span>stripPointerCasts());
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          // Simple Extracting Failed
</span></span><span style="display:flex;"><span>          // Use our own implementation
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (calledFunction <span style="color:#ec0000">==</span> <span style="color:#ec0000">NULL</span>) {
</span></span><span style="display:flex;"><span>            DEBUG_WITH_TYPE(
</span></span><span style="display:flex;"><span>                <span style="color:#008900">&#34;opt&#34;</span>, errs()
</span></span><span style="display:flex;"><span>                           <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;Failed To Extract Function From Indirect Call: &#34;</span>
</span></span><span style="display:flex;"><span>                           <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#ec0000">*</span>CS.getCalledValue() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          // It&#39;s only safe to restrict our modification to external symbols
</span></span><span style="display:flex;"><span>          // Otherwise stripped binary will crash
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>calledFunction<span style="color:#ec0000">-&gt;</span>empty() <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>              calledFunction<span style="color:#ec0000">-&gt;</span>getName().equals(<span style="color:#008900">&#34;dlsym&#34;</span>) <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>              calledFunction<span style="color:#ec0000">-&gt;</span>getName().equals(<span style="color:#008900">&#34;dlopen&#34;</span>) <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>              calledFunction<span style="color:#ec0000">-&gt;</span>isIntrinsic()) {
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">continue</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          // errs()&lt;&lt;&#34;Searching For:&#34;&lt;&lt;calledFunction-&gt;getName()&lt;&lt;&#34; In
</span></span><span style="display:flex;"><span>          // Configuration\n&#34;;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">if</span> (<span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;</span>Configuration.find(calledFunction<span style="color:#ec0000">-&gt;</span>getName().str()) <span style="color:#ec0000">!=</span>
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;</span>Configuration.end()) {
</span></span><span style="display:flex;"><span>            string sname <span style="color:#ec0000">=</span> <span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;</span>Configuration[calledFunction<span style="color:#ec0000">-&gt;</span>getName().str()]
</span></span><span style="display:flex;"><span>                               .get<span style="color:#ec0000">&lt;</span>string<span style="color:#ec0000">&gt;</span>();
</span></span><span style="display:flex;"><span>            StringRef calledFunctionName <span style="color:#ec0000">=</span> StringRef(sname);
</span></span><span style="display:flex;"><span>            BasicBlock <span style="color:#ec0000">*</span>EntryBlock <span style="color:#ec0000">=</span> CS<span style="color:#ec0000">-&gt;</span>getParent();
</span></span><span style="display:flex;"><span>            IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(EntryBlock, EntryBlock<span style="color:#ec0000">-&gt;</span>getFirstInsertionPt());
</span></span><span style="display:flex;"><span>            vector<span style="color:#ec0000">&lt;</span>Value <span style="color:#ec0000">*&gt;</span> dlopenargs;
</span></span><span style="display:flex;"><span>            dlopenargs.push_back(Constant<span style="color:#ec0000">::</span>getNullValue(Int8PtrTy));
</span></span><span style="display:flex;"><span>             <span style="color:#ec0000">if</span> (Tri.isOSDarwin()) {
</span></span><span style="display:flex;"><span>              dlopen_flag<span style="color:#ec0000">=</span>DARWIN_FLAG;
</span></span><span style="display:flex;"><span>            } <span style="color:#ec0000">else</span> <span style="color:#ec0000">if</span> (Tri.isAndroid()) {
</span></span><span style="display:flex;"><span>              <span style="color:#ec0000">if</span> (Tri.isArch64Bit()) {
</span></span><span style="display:flex;"><span>                dlopen_flag<span style="color:#ec0000">=</span>ANDROID64_FLAG;
</span></span><span style="display:flex;"><span>              } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>                dlopen_flag<span style="color:#ec0000">=</span>ANDROID32_FLAG;
</span></span><span style="display:flex;"><span>              }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>              errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;[FunctionCallObfuscate]Unsupported Target Triple:&#34;</span>
</span></span><span style="display:flex;"><span>                         <span style="color:#ec0000">&lt;&lt;</span> F.getParent()<span style="color:#ec0000">-&gt;</span>getTargetTriple() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>              errs()<span style="color:#ec0000">&lt;&lt;</span><span style="color:#008900">&#34;[FunctionCallObfuscate]Applying Default Signature:&#34;</span><span style="color:#ec0000">&lt;&lt;</span>dlopen_flag<span style="color:#ec0000">&lt;&lt;</span><span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            dlopenargs.push_back(ConstantInt<span style="color:#ec0000">::</span>get(Int32Ty, dlopen_flag));
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>Handle <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                IRB.CreateCall(dlopen_decl, ArrayRef<span style="color:#ec0000">&lt;</span>Value <span style="color:#ec0000">*&gt;</span>(dlopenargs));
</span></span><span style="display:flex;"><span>            // Create dlsym call
</span></span><span style="display:flex;"><span>            vector<span style="color:#ec0000">&lt;</span>Value <span style="color:#ec0000">*&gt;</span> args;
</span></span><span style="display:flex;"><span>            args.push_back(Handle);
</span></span><span style="display:flex;"><span>            args.push_back(IRB.CreateGlobalStringPtr(calledFunctionName));
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>fp <span style="color:#ec0000">=</span> IRB.CreateCall(dlsym_decl, ArrayRef<span style="color:#ec0000">&lt;</span>Value <span style="color:#ec0000">*&gt;</span>(args));
</span></span><span style="display:flex;"><span>            Value <span style="color:#ec0000">*</span>bitCastedFunction <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>                IRB.CreateBitCast(fp, CS.getCalledValue()<span style="color:#ec0000">-&gt;</span>getType());
</span></span><span style="display:flex;"><span>            CS.setCalledFunction(bitCastedFunction);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  ret i32 0
}
</code></pre><p>已混淆IR(<code>-mllvm -enable-fco</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %0 = call i8* @dlopen(i8* null, i32 10)
  %1 = call i8* @dlsym(i8* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @0, i32 0, i32 0))
  %2 = bitcast i8* %1 to i32 (i8*, ...)*
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %3 = getelementptr inbounds [3 x i8], [3 x i8]* @.str, i32 0, i32 0
  %call = call i32 (i8*, ...) %2(i8* %3)
  ret i32 0
}
</code></pre><p>   fco是Instruction层的混淆，可以将API调用构造为动态调用。</p>
<h3 id="hikari-functionwrapper模块分析">Hikari FunctionWrapper模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  CallSite <span style="color:#ec0000">*</span><span style="color:#5f5fff">HandleCallSite</span>(CallSite <span style="color:#ec0000">*</span>CS) {
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>calledFunction <span style="color:#ec0000">=</span> CS<span style="color:#ec0000">-&gt;</span>getCalledFunction();
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (calledFunction <span style="color:#ec0000">==</span> <span style="color:#ec0000">nullptr</span>) {
</span></span><span style="display:flex;"><span>      calledFunction <span style="color:#ec0000">=</span> CS<span style="color:#ec0000">-&gt;</span>getCalledValue()<span style="color:#ec0000">-&gt;</span>stripPointerCasts();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    // Filter out IndirectCalls that depends on the context
</span></span><span style="display:flex;"><span>    // Otherwise It&#39;ll be blantantly troublesome since you can&#39;t reference an
</span></span><span style="display:flex;"><span>    // Instruction outside its BB  Too much trouble for a hobby project
</span></span><span style="display:flex;"><span>    // To be precise, we only keep CS that refers to a non-intrinsic function
</span></span><span style="display:flex;"><span>    // either directly or through casting
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (calledFunction <span style="color:#ec0000">==</span> <span style="color:#ec0000">nullptr</span> <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#ec0000">!</span>isa<span style="color:#ec0000">&lt;</span>ConstantExpr<span style="color:#ec0000">&gt;</span>(calledFunction) <span style="color:#ec0000">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>         <span style="color:#ec0000">!</span>isa<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(calledFunction)) <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>        CS<span style="color:#ec0000">-&gt;</span>getIntrinsicID() <span style="color:#ec0000">!=</span> Intrinsic<span style="color:#ec0000">::</span>ID<span style="color:#ec0000">::</span>not_intrinsic) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (Function <span style="color:#ec0000">*</span>tmp <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(calledFunction)) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (tmp<span style="color:#ec0000">-&gt;</span>getName().startswith(<span style="color:#008900">&#34;clang.&#34;</span>)) {
</span></span><span style="display:flex;"><span>        // Clang Intrinsic
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">return</span> <span style="color:#ec0000">nullptr</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span>(<span style="color:#ec0000">auto</span> argiter <span style="color:#ec0000">=</span> tmp<span style="color:#ec0000">-&gt;</span>arg_begin(); argiter<span style="color:#ec0000">!=</span> tmp<span style="color:#ec0000">-&gt;</span>arg_end(); <span style="color:#ec0000">++</span>argiter) {
</span></span><span style="display:flex;"><span>       Argument<span style="color:#ec0000">&amp;</span> arg<span style="color:#ec0000">=*</span>(argiter);
</span></span><span style="display:flex;"><span>       <span style="color:#ec0000">if</span>(arg.hasByValAttr()){
</span></span><span style="display:flex;"><span>        // Arguments with byval attribute yields issues without proper handling.
</span></span><span style="display:flex;"><span>        // The &#34;proper&#34; method to handle this is to revisit and patch attribute stealing code.
</span></span><span style="display:flex;"><span>        // Technically readonly attr probably should also get filtered out here.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Nah too much work. This would do for open-source version since private already
</span></span><span style="display:flex;"><span>        // this pass with more advanced solutions 
</span></span><span style="display:flex;"><span>	<span style="color:#ec0000">return</span> <span style="color:#ec0000">nullptr</span>;       
</span></span><span style="display:flex;"><span>       }   
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    // Create a new function which in turn calls the actual function
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span> types;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> CS<span style="color:#ec0000">-&gt;</span>getNumArgOperands(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>      types.push_back(CS<span style="color:#ec0000">-&gt;</span>getArgOperand(i)<span style="color:#ec0000">-&gt;</span>getType());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    FunctionType <span style="color:#ec0000">*</span>ft <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        FunctionType<span style="color:#ec0000">::</span>get(CS<span style="color:#ec0000">-&gt;</span>getType(), ArrayRef<span style="color:#ec0000">&lt;</span>Type <span style="color:#ec0000">*&gt;</span>(types), <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>    Function <span style="color:#ec0000">*</span>func <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        Function<span style="color:#ec0000">::</span>Create(ft, GlobalValue<span style="color:#ec0000">::</span>LinkageTypes<span style="color:#ec0000">::</span>InternalLinkage,
</span></span><span style="display:flex;"><span>                         <span style="color:#008900">&#34;HikariFunctionWrapper&#34;</span>, CS<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getModule());
</span></span><span style="display:flex;"><span>      //Trolling was all fun and shit so old implementation forced this symbol to exist in all objects
</span></span><span style="display:flex;"><span>    appendToCompilerUsed(<span style="color:#ec0000">*</span>func<span style="color:#ec0000">-&gt;</span>getParent(), {func});
</span></span><span style="display:flex;"><span>    BasicBlock <span style="color:#ec0000">*</span>BB <span style="color:#ec0000">=</span> BasicBlock<span style="color:#ec0000">::</span>Create(func<span style="color:#ec0000">-&gt;</span>getContext(), <span style="color:#008900">&#34;&#34;</span>, func);
</span></span><span style="display:flex;"><span>    IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(BB);
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>Value <span style="color:#ec0000">*&gt;</span> params;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> arg <span style="color:#ec0000">=</span> func<span style="color:#ec0000">-&gt;</span>arg_begin(); arg <span style="color:#ec0000">!=</span> func<span style="color:#ec0000">-&gt;</span>arg_end(); arg<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>      params.push_back(arg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>retval <span style="color:#ec0000">=</span> IRB.CreateCall(ConstantExpr<span style="color:#ec0000">::</span>getBitCast(cast<span style="color:#ec0000">&lt;</span>Function<span style="color:#ec0000">&gt;</span>(calledFunction),CS<span style="color:#ec0000">-&gt;</span>getCalledValue()<span style="color:#ec0000">-&gt;</span>getType()), ArrayRef<span style="color:#ec0000">&lt;</span>Value <span style="color:#ec0000">*&gt;</span>(params));
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (ft<span style="color:#ec0000">-&gt;</span>getReturnType()<span style="color:#ec0000">-&gt;</span>isVoidTy()) {
</span></span><span style="display:flex;"><span>      IRB.CreateRetVoid();
</span></span><span style="display:flex;"><span>    } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>      IRB.CreateRet(retval);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    CS<span style="color:#ec0000">-&gt;</span>setCalledFunction(func);
</span></span><span style="display:flex;"><span>    CS<span style="color:#ec0000">-&gt;</span>mutateFunctionType(ft);
</span></span><span style="display:flex;"><span>    Instruction <span style="color:#ec0000">*</span>Inst <span style="color:#ec0000">=</span> CS<span style="color:#ec0000">-&gt;</span>getInstruction();
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">delete</span> CS;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">new</span> CallSite(Inst);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define void @_Z4funcv() #0 {
entry:
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  ret void
}

define i32 @main(i32 %argc, i8** %argv) #2 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  call void @_Z4funcv()
  ret i32 0
}
</code></pre><p>已混淆IR(<code>-mllvm -enable-funcwra</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define void @_Z4funcv() #0 {
entry:
  %call = call i32 @HikariFunctionWrapper.1(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  ret void
}

define i32 @main(i32 %argc, i8** %argv) #2 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  call void @HikariFunctionWrapper.3()
  ret i32 0
}

define internal i32 @HikariFunctionWrapper(i8*) {
  %2 = call i32 (i8*, ...) @printf(i8* %0)
  ret i32 %2
}

define internal i32 @HikariFunctionWrapper.1(i8*) {
  %2 = call i32 @HikariFunctionWrapper(i8* %0)
  ret i32 %2
}

define internal void @HikariFunctionWrapper.2() {
  call void @_Z4funcv()
  ret void
}

define internal void @HikariFunctionWrapper.3() {
  call void @HikariFunctionWrapper.2()
  ret void
}
</code></pre><pre class="mermaid">flowchart LR
A([main]) --> B([HikariFunctionWrapper.3])
B([HikariFunctionWrapper.3]) --> C([HikariFunctionWrapper.2])
C([HikariFunctionWrapper.2]) --> D([_Z4funcv])
D([_Z4funcv]) --> E([HikariFunctionWrapper.1])
E([HikariFunctionWrapper.1]) --> F([HikariFunctionWrapper])
F([HikariFunctionWrapper]) --> G([printf])
</pre>
<p>  fw是Function层的混淆，可以将函数调用构造为调用多个嵌套空函数。</p>
<h2 id="指令级别的混淆">指令级别的混淆</h2>
<h3 id="hikari-indirectbranch模块分析">Hikari IndirectBranch模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">initialize</span>(Module <span style="color:#ec0000">&amp;</span>M) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*&gt;</span> BBs;
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">unsigned</span> <span style="color:#5f5fff">long</span> <span style="color:#5f5fff">long</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> F <span style="color:#ec0000">=</span> M.begin(); F <span style="color:#ec0000">!=</span> M.end(); F<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> BB <span style="color:#ec0000">=</span> F<span style="color:#ec0000">-&gt;</span>begin(); BB <span style="color:#ec0000">!=</span> F<span style="color:#ec0000">-&gt;</span>end(); BB<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>        BasicBlock <span style="color:#ec0000">*</span>BBPtr <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;*</span>BB;
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (BBPtr <span style="color:#ec0000">!=</span> <span style="color:#ec0000">&amp;</span>(BBPtr<span style="color:#ec0000">-&gt;</span>getParent()<span style="color:#ec0000">-&gt;</span>getEntryBlock())) {
</span></span><span style="display:flex;"><span>          indexmap[BBPtr] <span style="color:#ec0000">=</span> i<span style="color:#ec0000">++</span>;
</span></span><span style="display:flex;"><span>          BBs.push_back(BlockAddress<span style="color:#ec0000">::</span>get(BBPtr));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ArrayType <span style="color:#ec0000">*</span>AT <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        ArrayType<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt8PtrTy(M.getContext()), BBs.size());
</span></span><span style="display:flex;"><span>    Constant <span style="color:#ec0000">*</span>BlockAddressArray <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        ConstantArray<span style="color:#ec0000">::</span>get(AT, ArrayRef<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*&gt;</span>(BBs));
</span></span><span style="display:flex;"><span>    GlobalVariable <span style="color:#ec0000">*</span>Table <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> GlobalVariable(
</span></span><span style="display:flex;"><span>        M, AT, <span style="color:#ec0000">false</span>, GlobalValue<span style="color:#ec0000">::</span>LinkageTypes<span style="color:#ec0000">::</span>InternalLinkage,
</span></span><span style="display:flex;"><span>        BlockAddressArray, <span style="color:#008900">&#34;IndirectBranchingGlobalTable&#34;</span>);
</span></span><span style="display:flex;"><span>    appendToCompilerUsed(M, {Table});
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">runOnFunction</span>(Function <span style="color:#ec0000">&amp;</span>Func) <span style="color:#ec0000">override</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>toObfuscate(flag, <span style="color:#ec0000">&amp;</span>Func, <span style="color:#008900">&#34;indibr&#34;</span>)) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;</span>initialized <span style="color:#ec0000">==</span> <span style="color:#ec0000">false</span>) {
</span></span><span style="display:flex;"><span>      initialize(<span style="color:#ec0000">*</span>Func.getParent());
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;</span>initialized <span style="color:#ec0000">=</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    errs() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;Running IndirectBranch On &#34;</span> <span style="color:#ec0000">&lt;&lt;</span> Func.getName() <span style="color:#ec0000">&lt;&lt;</span> <span style="color:#008900">&#34;</span><span style="color:#008900">\n</span><span style="color:#008900">&#34;</span>;
</span></span><span style="display:flex;"><span>    vector<span style="color:#ec0000">&lt;</span>BranchInst <span style="color:#ec0000">*&gt;</span> BIs;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (inst_iterator I <span style="color:#ec0000">=</span> inst_begin(Func); I <span style="color:#ec0000">!=</span> inst_end(Func); I<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>      Instruction <span style="color:#ec0000">*</span>Inst <span style="color:#ec0000">=</span> <span style="color:#ec0000">&amp;</span>(<span style="color:#ec0000">*</span>I);
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (BranchInst <span style="color:#ec0000">*</span>BI <span style="color:#ec0000">=</span> dyn_cast<span style="color:#ec0000">&lt;</span>BranchInst<span style="color:#ec0000">&gt;</span>(Inst)) {
</span></span><span style="display:flex;"><span>        BIs.push_back(BI);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } // Finish collecting branching conditions
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>zero <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>        ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Func.getParent()<span style="color:#ec0000">-&gt;</span>getContext()), <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (BranchInst <span style="color:#ec0000">*</span><span style="color:#ec0000">BI</span> : BIs) {
</span></span><span style="display:flex;"><span>      IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(BI);
</span></span><span style="display:flex;"><span>      vector<span style="color:#ec0000">&lt;</span>BasicBlock <span style="color:#ec0000">*&gt;</span> BBs;
</span></span><span style="display:flex;"><span>      // We use the condition&#39;s evaluation result to generate the GEP
</span></span><span style="display:flex;"><span>      // instruction  False evaluates to 0 while true evaluates to 1.  So here
</span></span><span style="display:flex;"><span>      // we insert the false block first
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (BI<span style="color:#ec0000">-&gt;</span>isConditional()) {
</span></span><span style="display:flex;"><span>        BBs.push_back(BI<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">1</span>));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      BBs.push_back(BI<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>));
</span></span><span style="display:flex;"><span>      ArrayType <span style="color:#ec0000">*</span>AT <span style="color:#ec0000">=</span> ArrayType<span style="color:#ec0000">::</span>get(
</span></span><span style="display:flex;"><span>          Type<span style="color:#ec0000">::</span>getInt8PtrTy(Func.getParent()<span style="color:#ec0000">-&gt;</span>getContext()), BBs.size());
</span></span><span style="display:flex;"><span>      vector<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*&gt;</span> BlockAddresses;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>; i <span style="color:#ec0000">&lt;</span> BBs.size(); i<span style="color:#ec0000">++</span>) {
</span></span><span style="display:flex;"><span>        BlockAddresses.push_back(BlockAddress<span style="color:#ec0000">::</span>get(BBs[i]));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      GlobalVariable <span style="color:#ec0000">*</span>LoadFrom <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (BI<span style="color:#ec0000">-&gt;</span>isConditional() <span style="color:#ec0000">||</span>
</span></span><span style="display:flex;"><span>          indexmap.find(BI<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>)) <span style="color:#ec0000">==</span> indexmap.end()) {
</span></span><span style="display:flex;"><span>        // Create a new GV
</span></span><span style="display:flex;"><span>        Constant <span style="color:#ec0000">*</span>BlockAddressArray <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>            ConstantArray<span style="color:#ec0000">::</span>get(AT, ArrayRef<span style="color:#ec0000">&lt;</span>Constant <span style="color:#ec0000">*&gt;</span>(BlockAddresses));
</span></span><span style="display:flex;"><span>        LoadFrom <span style="color:#ec0000">=</span> <span style="color:#ec0000">new</span> GlobalVariable(
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">*</span>Func.getParent(), AT, <span style="color:#ec0000">false</span>,
</span></span><span style="display:flex;"><span>            GlobalValue<span style="color:#ec0000">::</span>LinkageTypes<span style="color:#ec0000">::</span>PrivateLinkage, BlockAddressArray,
</span></span><span style="display:flex;"><span>            <span style="color:#008900">&#34;HikariConditionalLocalIndirectBranchingTable&#34;</span>);
</span></span><span style="display:flex;"><span>        appendToCompilerUsed(<span style="color:#ec0000">*</span>Func.getParent(), {LoadFrom});
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>        LoadFrom <span style="color:#ec0000">=</span> Func.getParent()<span style="color:#ec0000">-&gt;</span>getGlobalVariable(
</span></span><span style="display:flex;"><span>            <span style="color:#008900">&#34;IndirectBranchingGlobalTable&#34;</span>, <span style="color:#ec0000">true</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>index <span style="color:#ec0000">=</span> <span style="color:#ec0000">NULL</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (BI<span style="color:#ec0000">-&gt;</span>isConditional()) {
</span></span><span style="display:flex;"><span>        Value <span style="color:#ec0000">*</span>condition <span style="color:#ec0000">=</span> BI<span style="color:#ec0000">-&gt;</span>getCondition();
</span></span><span style="display:flex;"><span>        index <span style="color:#ec0000">=</span> IRB.CreateZExt(
</span></span><span style="display:flex;"><span>            condition, Type<span style="color:#ec0000">::</span>getInt32Ty(Func.getParent()<span style="color:#ec0000">-&gt;</span>getContext()));
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>        index <span style="color:#ec0000">=</span>
</span></span><span style="display:flex;"><span>            ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Func.getParent()<span style="color:#ec0000">-&gt;</span>getContext()),
</span></span><span style="display:flex;"><span>                             indexmap[BI<span style="color:#ec0000">-&gt;</span>getSuccessor(<span style="color:#008900">0</span>)]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>GEP <span style="color:#ec0000">=</span> IRB.CreateGEP(LoadFrom, {zero, index});
</span></span><span style="display:flex;"><span>      LoadInst <span style="color:#ec0000">*</span>LI <span style="color:#ec0000">=</span> IRB.CreateLoad(GEP, <span style="color:#008900">&#34;IndirectBranchingTargetAddress&#34;</span>);
</span></span><span style="display:flex;"><span>      IndirectBrInst <span style="color:#ec0000">*</span>indirBr <span style="color:#ec0000">=</span> IndirectBrInst<span style="color:#ec0000">::</span>Create(LI, BBs.size());
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (BasicBlock <span style="color:#ec0000">*</span><span style="color:#ec0000">BB</span> : BBs) {
</span></span><span style="display:flex;"><span>        indirBr<span style="color:#ec0000">-&gt;</span>addDestination(BB);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      ReplaceInstWithInst(BI, indirBr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">virtual</span> <span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">doFinalization</span>(Module <span style="color:#ec0000">&amp;</span>M) <span style="color:#ec0000">override</span> {
</span></span><span style="display:flex;"><span>    indexmap.clear();
</span></span><span style="display:flex;"><span>    initialized <span style="color:#ec0000">=</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}
</code></pre><p>已混淆IR(<code>-mllvm -enable-indibran</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@IndirectBranchingGlobalTable = internal global [2 x i8*] [i8* blockaddress(@main, %if.then), i8* blockaddress(@main, %if.end)]
@HikariConditionalLocalIndirectBranchingTable = private global [2 x i8*] [i8* blockaddress(@main, %if.end), i8* blockaddress(@main, %if.then)]
@llvm.compiler.used = appending global [2 x i8*] [i8* bitcast ([2 x i8*]* @IndirectBranchingGlobalTable to i8*), i8* bitcast ([2 x i8*]* @HikariConditionalLocalIndirectBranchingTable to i8*)], section &#34;llvm.metadata&#34;

define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp eq i32 %0, 0
  %1 = zext i1 %cmp to i32
  %2 = getelementptr [2 x i8*], [2 x i8*]* @HikariConditionalLocalIndirectBranchingTable, i32 0, i32 %1
  %IndirectBranchingTargetAddress = load i8*, i8** %2
  indirectbr i8* %IndirectBranchingTargetAddress, [label %if.end, label %if.then]

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0))
  %IndirectBranchingTargetAddress1 = load i8*, i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @IndirectBranchingGlobalTable, i32 0, i32 1)
  indirectbr i8* %IndirectBranchingTargetAddress1, [label %if.end]

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}
</code></pre><p>  indibr是Instruction层的混淆，可以将分支指令降级(lower)为间接分支指令.</p>
<h3 id="hikari-substitution模块分析">Hikari Substitution模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5f5fff">bool</span> Substitution<span style="color:#ec0000">::</span>substitute(Function <span style="color:#ec0000">*</span>f) {
</span></span><span style="display:flex;"><span>  Function <span style="color:#ec0000">*</span>tmp <span style="color:#ec0000">=</span> f;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  // Loop for the number of time we run the pass on the function
</span></span><span style="display:flex;"><span>  <span style="color:#5f5fff">int</span> times <span style="color:#ec0000">=</span> ObfTimes;
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (Function<span style="color:#ec0000">::</span>iterator bb <span style="color:#ec0000">=</span> tmp<span style="color:#ec0000">-&gt;</span>begin(); bb <span style="color:#ec0000">!=</span> tmp<span style="color:#ec0000">-&gt;</span>end(); <span style="color:#ec0000">++</span>bb) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (BasicBlock<span style="color:#ec0000">::</span>iterator inst <span style="color:#ec0000">=</span> bb<span style="color:#ec0000">-&gt;</span>begin(); inst <span style="color:#ec0000">!=</span> bb<span style="color:#ec0000">-&gt;</span>end(); <span style="color:#ec0000">++</span>inst) {
</span></span><span style="display:flex;"><span>        <span style="color:#ec0000">if</span> (inst<span style="color:#ec0000">-&gt;</span>isBinaryOp() <span style="color:#ec0000">&amp;&amp;</span> cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">100</span>) <span style="color:#ec0000">&lt;=</span> ObfProbRate) {
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">switch</span> (inst<span style="color:#ec0000">-&gt;</span>getOpcode()) {
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">Add</span>:
</span></span><span style="display:flex;"><span>            // case BinaryOperator::FAdd:
</span></span><span style="display:flex;"><span>            // Substitute with random add operation
</span></span><span style="display:flex;"><span>            (<span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;*</span>funcAdd[llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(NUMBER_ADD_SUBST)])(
</span></span><span style="display:flex;"><span>                cast<span style="color:#ec0000">&lt;</span>BinaryOperator<span style="color:#ec0000">&gt;</span>(inst));
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">++</span>Add;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">Sub</span>:
</span></span><span style="display:flex;"><span>            // case BinaryOperator::FSub:
</span></span><span style="display:flex;"><span>            // Substitute with random sub operation
</span></span><span style="display:flex;"><span>            (<span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;*</span>funcSub[llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(NUMBER_SUB_SUBST)])(
</span></span><span style="display:flex;"><span>                cast<span style="color:#ec0000">&lt;</span>BinaryOperator<span style="color:#ec0000">&gt;</span>(inst));
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">++</span>Sub;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">Mul</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">FMul</span>:
</span></span><span style="display:flex;"><span>            //++Mul;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">UDiv</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">SDiv</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">FDiv</span>:
</span></span><span style="display:flex;"><span>            //++Div;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">URem</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">SRem</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> BinaryOperator<span style="color:#ec0000">::</span><span style="color:#ec0000">FRem</span>:
</span></span><span style="display:flex;"><span>            //++Rem;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> Instruction<span style="color:#ec0000">::</span><span style="color:#ec0000">Shl</span>:
</span></span><span style="display:flex;"><span>            //++Shi;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> Instruction<span style="color:#ec0000">::</span><span style="color:#ec0000">LShr</span>:
</span></span><span style="display:flex;"><span>            //++Shi;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> Instruction<span style="color:#ec0000">::</span><span style="color:#ec0000">AShr</span>:
</span></span><span style="display:flex;"><span>            //++Shi;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> Instruction<span style="color:#ec0000">::</span><span style="color:#ec0000">And</span>:
</span></span><span style="display:flex;"><span>            (<span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;*</span>funcAnd[llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">2</span>)])(
</span></span><span style="display:flex;"><span>                cast<span style="color:#ec0000">&lt;</span>BinaryOperator<span style="color:#ec0000">&gt;</span>(inst));
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">++</span>And;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> Instruction<span style="color:#ec0000">::</span><span style="color:#ec0000">Or</span>:
</span></span><span style="display:flex;"><span>            (<span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;*</span>funcOr[llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">2</span>)])(
</span></span><span style="display:flex;"><span>                cast<span style="color:#ec0000">&lt;</span>BinaryOperator<span style="color:#ec0000">&gt;</span>(inst));
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">++</span>Or;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">case</span> Instruction<span style="color:#ec0000">::</span><span style="color:#ec0000">Xor</span>:
</span></span><span style="display:flex;"><span>            (<span style="color:#ec0000">this</span><span style="color:#ec0000">-&gt;*</span>funcXor[llvm<span style="color:#ec0000">::</span>cryptoutils<span style="color:#ec0000">-&gt;</span>get_range(<span style="color:#008900">2</span>)])(
</span></span><span style="display:flex;"><span>                cast<span style="color:#ec0000">&lt;</span>BinaryOperator<span style="color:#ec0000">&gt;</span>(inst));
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">++</span>Xor;
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#ec0000">default</span><span style="color:#ec0000">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ec0000">break</span>;
</span></span><span style="display:flex;"><span>          }              // End switch
</span></span><span style="display:flex;"><span>        }                // End isBinaryOp
</span></span><span style="display:flex;"><span>      }                  // End for basickblock
</span></span><span style="display:flex;"><span>    }                    // End for Function
</span></span><span style="display:flex;"><span>  } <span style="color:#ec0000">while</span> (<span style="color:#ec0000">--</span>times <span style="color:#ec0000">&gt;</span> <span style="color:#008900">0</span>); // for times
</span></span><span style="display:flex;"><span>  <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %add = add nsw i32 %0, 2
  %sub = sub nsw i32 %add, 1
  %add1 = add nsw i32 %sub, 3
  %sub2 = sub nsw i32 %add1, 2
  ret i32 %sub2
}
</code></pre><p>已混淆IR(<code>-mllvm -enable-subobf</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %1 = sub i32 0, 2
  %2 = sub i32 %0, %1
  %add = add nsw i32 %0, 2
  %3 = add i32 %2, 1155499931
  %4 = sub i32 %3, 1
  %5 = sub i32 %4, 1155499931
  %sub = sub nsw i32 %2, 1
  %add1 = add nsw i32 %5, 3
  %6 = sub i32 0, 2
  %7 = add i32 %add1, %6
  %sub2 = sub nsw i32 %add1, 2
  ret i32 %7
}
</code></pre><p>  sub是Instruction层混淆，可以将add/sub/and/or/xor等简单二元操作替换为等价的一系列简单指令。此功能是原始ollvm就存在的，对IDA这样成熟的逆向工具来说没什么实际效果，都被自动优化了。</p>
<h3 id="goron-indirectcall模块分析">goron IndirectCall模块分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#757575;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#5f5fff">bool</span> <span style="color:#5f5fff">runOnFunction</span>(Function <span style="color:#ec0000">&amp;</span>Fn) <span style="color:#ec0000">override</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (<span style="color:#ec0000">!</span>toObfuscate(flag, <span style="color:#ec0000">&amp;</span>Fn, <span style="color:#008900">&#34;icall&#34;</span>)) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (Options <span style="color:#ec0000">&amp;&amp;</span> Options<span style="color:#ec0000">-&gt;</span>skipFunction(Fn.getName())) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LLVMContext <span style="color:#ec0000">&amp;</span>Ctx <span style="color:#ec0000">=</span> Fn.getContext();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    CalleeNumbering.clear();
</span></span><span style="display:flex;"><span>    Callees.clear();
</span></span><span style="display:flex;"><span>    CallSites.clear();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    NumberCallees(Fn);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (Callees.empty()) {
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">return</span> <span style="color:#ec0000">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#5f5fff">uint32_t</span> V <span style="color:#ec0000">=</span> RandomEngine.get_uint32_t() <span style="color:#ec0000">&amp;</span> <span style="color:#ec0000">~</span><span style="color:#008900">3</span>;
</span></span><span style="display:flex;"><span>    ConstantInt <span style="color:#ec0000">*</span>EncKey <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), V, <span style="color:#ec0000">false</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">const</span> IPObfuscationContext<span style="color:#ec0000">::</span>IPOInfo <span style="color:#ec0000">*</span>SecretInfo <span style="color:#ec0000">=</span> <span style="color:#ec0000">nullptr</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (IPO) {
</span></span><span style="display:flex;"><span>      SecretInfo <span style="color:#ec0000">=</span> IPO<span style="color:#ec0000">-&gt;</span>getIPOInfo(<span style="color:#ec0000">&amp;</span>Fn);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Value <span style="color:#ec0000">*</span>MySecret;
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">if</span> (SecretInfo) {
</span></span><span style="display:flex;"><span>      MySecret <span style="color:#ec0000">=</span> SecretInfo<span style="color:#ec0000">-&gt;</span>SecretLI;
</span></span><span style="display:flex;"><span>    } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>      MySecret <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), <span style="color:#008900">0</span>, <span style="color:#ec0000">true</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ConstantInt <span style="color:#ec0000">*</span>Zero <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), <span style="color:#008900">0</span>);
</span></span><span style="display:flex;"><span>    GlobalVariable <span style="color:#ec0000">*</span>Targets <span style="color:#ec0000">=</span> getIndirectCallees(Fn, EncKey);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">for</span> (<span style="color:#ec0000">auto</span> <span style="color:#ec0000">CI</span> : CallSites) {
</span></span><span style="display:flex;"><span>      SmallVector<span style="color:#ec0000">&lt;</span>Value <span style="color:#ec0000">*</span>, <span style="color:#008900">8</span><span style="color:#ec0000">&gt;</span> Args;
</span></span><span style="display:flex;"><span>      SmallVector<span style="color:#ec0000">&lt;</span>AttributeSet, <span style="color:#008900">8</span><span style="color:#ec0000">&gt;</span> ArgAttrVec;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      CallSite CS(CI);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      Instruction <span style="color:#ec0000">*</span>Call <span style="color:#ec0000">=</span> CS.getInstruction();
</span></span><span style="display:flex;"><span>      Function <span style="color:#ec0000">*</span>Callee <span style="color:#ec0000">=</span> CS.getCalledFunction();
</span></span><span style="display:flex;"><span>      FunctionType <span style="color:#ec0000">*</span>FTy <span style="color:#ec0000">=</span> CS.getFunctionType();
</span></span><span style="display:flex;"><span>      IRBuilder<span style="color:#ec0000">&lt;&gt;</span> IRB(Call);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      Args.clear();
</span></span><span style="display:flex;"><span>      ArgAttrVec.clear();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>Idx <span style="color:#ec0000">=</span> ConstantInt<span style="color:#ec0000">::</span>get(Type<span style="color:#ec0000">::</span>getInt32Ty(Ctx), CalleeNumbering[CS.getCalledFunction()]);
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>GEP <span style="color:#ec0000">=</span> IRB.CreateGEP(Targets, {Zero, Idx});
</span></span><span style="display:flex;"><span>      LoadInst <span style="color:#ec0000">*</span>EncDestAddr <span style="color:#ec0000">=</span> IRB.CreateLoad(GEP, CI<span style="color:#ec0000">-&gt;</span>getName());
</span></span><span style="display:flex;"><span>      Constant <span style="color:#ec0000">*</span>X;
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">if</span> (SecretInfo) {
</span></span><span style="display:flex;"><span>        X <span style="color:#ec0000">=</span> ConstantExpr<span style="color:#ec0000">::</span>getSub(SecretInfo<span style="color:#ec0000">-&gt;</span>SecretCI, EncKey);
</span></span><span style="display:flex;"><span>      } <span style="color:#ec0000">else</span> {
</span></span><span style="display:flex;"><span>        X <span style="color:#ec0000">=</span> ConstantExpr<span style="color:#ec0000">::</span>getSub(Zero, EncKey);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">const</span> AttributeList <span style="color:#ec0000">&amp;</span>CallPAL <span style="color:#ec0000">=</span> CS.getAttributes();
</span></span><span style="display:flex;"><span>      CallSite<span style="color:#ec0000">::</span>arg_iterator I <span style="color:#ec0000">=</span> CS.arg_begin();
</span></span><span style="display:flex;"><span>      <span style="color:#5f5fff">unsigned</span> i <span style="color:#ec0000">=</span> <span style="color:#008900">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (<span style="color:#5f5fff">unsigned</span> e <span style="color:#ec0000">=</span> FTy<span style="color:#ec0000">-&gt;</span>getNumParams(); i <span style="color:#ec0000">!=</span> e; <span style="color:#ec0000">++</span>I, <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>        Args.push_back(<span style="color:#ec0000">*</span>I);
</span></span><span style="display:flex;"><span>        AttributeSet Attrs <span style="color:#ec0000">=</span> CallPAL.getParamAttributes(i);
</span></span><span style="display:flex;"><span>        ArgAttrVec.push_back(Attrs);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ec0000">for</span> (CallSite<span style="color:#ec0000">::</span>arg_iterator E <span style="color:#ec0000">=</span> CS.arg_end(); I <span style="color:#ec0000">!=</span> E; <span style="color:#ec0000">++</span>I, <span style="color:#ec0000">++</span>i) {
</span></span><span style="display:flex;"><span>        Args.push_back(<span style="color:#ec0000">*</span>I);
</span></span><span style="display:flex;"><span>        ArgAttrVec.push_back(CallPAL.getParamAttributes(i));
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      AttributeList NewCallPAL <span style="color:#ec0000">=</span> AttributeList<span style="color:#ec0000">::</span>get(
</span></span><span style="display:flex;"><span>          IRB.getContext(), CallPAL.getFnAttributes(), CallPAL.getRetAttributes(), ArgAttrVec);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>Secret <span style="color:#ec0000">=</span> IRB.CreateSub(X, MySecret);
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>DestAddr <span style="color:#ec0000">=</span> IRB.CreateGEP(EncDestAddr, Secret);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      Value <span style="color:#ec0000">*</span>FnPtr <span style="color:#ec0000">=</span> IRB.CreateBitCast(DestAddr, FTy<span style="color:#ec0000">-&gt;</span>getPointerTo());
</span></span><span style="display:flex;"><span>      FnPtr<span style="color:#ec0000">-&gt;</span>setName(<span style="color:#008900">&#34;Call_&#34;</span> <span style="color:#ec0000">+</span> Callee<span style="color:#ec0000">-&gt;</span>getName());
</span></span><span style="display:flex;"><span>      CallInst <span style="color:#ec0000">*</span>NewCall <span style="color:#ec0000">=</span> IRB.CreateCall(FTy, FnPtr, Args, Call<span style="color:#ec0000">-&gt;</span>getName());
</span></span><span style="display:flex;"><span>      NewCall<span style="color:#ec0000">-&gt;</span>setAttributes(NewCallPAL);
</span></span><span style="display:flex;"><span>      Call<span style="color:#ec0000">-&gt;</span>replaceAllUsesWith(NewCall);
</span></span><span style="display:flex;"><span>      Call<span style="color:#ec0000">-&gt;</span>eraseFromParent();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ec0000">return</span> <span style="color:#ec0000">true</span>;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>未混淆IR</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">define i32 @main(i32 noundef %argc, i8** noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}
</code></pre><p>已混淆IR(<code>-mllvm -irobf-indbr</code>)</p>
<pre tabindex="0"><code class="language-IR" data-lang="IR">@main_IndirectCallees = private global [1 x i8*] [i8* getelementptr (i8, i8* bitcast (i32 (i8*, ...)* @printf to i8*), i32 -912149244)]
@llvm.compiler.used = appending global [1 x i8*] [i8* bitcast ([1 x i8*]* @main_IndirectCallees to i8*)], section &#34;llvm.metadata&#34;

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %CallerSlot = alloca i32, align 4
  %CalleeSlot = alloca i32, align 4
  store i32 -407925950, i32* %CallerSlot
  %MySecret = load i32, i32* %CallerSlot
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = load i8*, i8** getelementptr inbounds ([1 x i8*], [1 x i8*]* @main_IndirectCallees, i32 0, i32 0)
  %1 = sub i32 504223294, %MySecret
  %2 = getelementptr i8, i8* %call1, i32 %1
  %Call_printf = bitcast i8* %2 to i32 (i8*, ...)*
  %call2 = call i32 (i8*, ...) %Call_printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i64 0, i64 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}
</code></pre><h2 id="ollvm对抗">OLLVM对抗</h2>
<h3 id="d810">D810</h3>
<h3 id="angr">angr</h3>

    
    <script src="https://giscus.app/client.js"
        data-repo="lich4/lich4.github.io"
        data-repo-id="R_kgDOMTT_mw"
        data-category=""
        data-category-id="DIC_kwDOMTT_m84Cjbim"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

    
  </div>

  
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script>
  


  

  
  

<div class="single-pagination">
    <hr />

    <div class="flex">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/cpp_posts/20230924_cpp_call_rust/">
                        C&#43;&#43;调用Rust
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


      </main>
    </div>

    <footer>
      

    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    



    </footer>
    
  </body>

  <script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>

</html>